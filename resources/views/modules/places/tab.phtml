<?php

use Fisharebest\Webtrees\I18N;

/**
 * @var array<mixed> $data
 * @var object       $leaflet_config
 */

?>

<div class="py-4">
    <div class="row gchart wt-places-tab-wrapper">
        <div id="wt-map" class="col-sm-9 wt-ajax-load wt-map wt-places-tab-map" dir="ltr"></div>
        <ul class="col-sm-3 wt-places-tab-sidebar wt-page-options-value list-unstyled px-md-1"></ul>
    </div>
</div>

<script>
  'use strict';

  (function () {
    const config = <?= json_encode($leaflet_config, JSON_THROW_ON_ERROR) ?>;

    let map = null;
    const sidebar = document.querySelector('.wt-places-tab-sidebar');

    const scrollOptions = {
      behavior: "smooth",
      block: "start",
      inline: "start"
    };

    const popupZoomLevel = 12; // 12 is a reasonable compromise for open clusters
    let spiderfyDelay = 300; // mS

    // Map components
    let markers = L.markerClusterGroup({
        showCoverageOnHover: false,
    });

    /**
     * Passed to resetControl to
     * perform necessary reset actions on map
     */
    let resetCallback = function () {
      map.flyToBounds(markers.getBounds(), {padding: [50, 30], maxZoom: 15 });
      sidebar.firstElementChild.scrollIntoView(scrollOptions);
      spiderfyDelay = 300;
    }

    /**
     *
     * @private
     */
    let _drawMap = function() {
      map = webtrees.buildLeafletJsMap('wt-map', config, resetCallback);
    };

    /**
     *
     * @private
     */
    let _buildMapData = function() {
      let data = <?= json_encode($data, JSON_THROW_ON_ERROR) ?>;

      if (data.features.length === 0) {
        map.fitWorld();
        sidebar.innerHTML = '<div class="bg-info text-white text-center">' + <?= json_encode(I18N::translate('Nothing to show'), JSON_THROW_ON_ERROR) ?> + '</div>';
      } else {
        sidebar.innerHTML = '';
        let geoJsonLayer = L.geoJson(data, {
          pointToLayer: function(feature, latlng) {
            return new L.Marker(latlng, {
              icon: L.BeautifyIcon.icon({
                icon           : feature.properties.icon["name"],
                borderColor    : "transparent",
                backgroundColor: feature.properties.icon["color"],
                iconShape      : "marker",
                textColor      : "white",
              }),
              title: feature.properties.tooltip,
              alt  : feature.properties.tooltip,
              id   : feature.id,
            })
            .on("popupopen", function(e) {
              let item = document.querySelector('.gchart[data-wt-feature-id="' + e.target.feature.id + '"]');
              item.classList.add('messagebox');
              item.scrollIntoView(scrollOptions);
            })
            .on("popupclose", function() {
              sidebar.querySelector('.gchart.messagebox').classList.remove('messagebox');
              sidebar.firstElementChild.scrollIntoView(scrollOptions);
            });
          },
          onEachFeature: function(feature, layer) {
              layer.bindPopup(feature.properties.summary);
              sidebar.innerHTML += `<li class="gchart px-md-2" data-wt-feature-id=${feature.id}>${feature.properties.summary}</li>`;
          },
        });
        markers.addLayer(geoJsonLayer);
        map.addLayer(markers);
        map.fitBounds(markers.getBounds(), {padding: [50, 30], maxZoom: 15});
      }
    };

    /**
     * @private
     *
     * @param {L.marker} marker
     * @param {string} eventName
     */
    const _fireEventOnMarkerOrVisibleParentCluster = function(marker, eventName) {
      if (eventName === 'click') {
        var visibleLayer = markers.getVisibleParent(marker);

        if (visibleLayer instanceof L.MarkerCluster) {
          // spiderfy its containing cluster to reveal it.
          // This will automatically unspiderfy other clusters.
          visibleLayer.spiderfy();
          // We want to show a marker that is currently hidden in a cluster.
          // Make sure it will get highlighted once revealed.
          markers.once('spiderfied', function() {
            marker.fire(eventName);
          });
        } else {
          // The marker is already visible, unspiderfy other clusters if
          // they do not contain the marker.
          _unspiderfyPreviousClusterIfNotParentOf(marker);
          marker.fire(eventName);
        }
      } else {
        // For mouseout, marker should be unclustered already, unless
        // the next mouseover happened before?
        marker.fire(eventName);
      }
    }

    /**
     * @private
     *
     * @param {L.marker} marker
     */
    const _unspiderfyPreviousClusterIfNotParentOf = function(marker) {
      // Check if there is a currently spiderfied cluster.
      // If so and it does not contain the marker, unspiderfy it.
      var spiderfiedCluster = markers._spiderfied;

      if (
        spiderfiedCluster
        && !_clusterContainsMarker(spiderfiedCluster, marker)
      ) {
        spiderfiedCluster.unspiderfy();
      }
    }

    /**
     * @private
     *
     * @param {L.clusterGroup} cluster
     * @param {L.marker} marker
     *
     * @returns {boolean}
     */
    const _clusterContainsMarker = function(cluster, marker) {
      var currentLayer = marker;

      while (currentLayer && currentLayer !== cluster) {
        currentLayer = currentLayer.__parent;
      }

      // Say if we found a cluster or nothing.
      return !!currentLayer;
    }

    /**
     * Can't use window.onload here. seems to be because of AJAX loading
     *
     * @private
     */
    const _loadListeners = function() {
      // Activate marker popup when sidebar entry clicked
      sidebar.addEventListener('click', (evt) => {
        // Only perform map action if evt was not initiated from an anchor element
        if (!evt.target.closest('a')) {
          //find the marker corresponding to the clicked event
          const eventId = parseInt(evt.target.closest('.gchart').dataset.wtFeatureId);
          let mkrLayer = markers.getLayers().filter(function (v) {
            return v.feature !== undefined && v.feature.id === eventId;
          });
          const mkr = mkrLayer.pop();

          if (mkr instanceof L.Layer) {
            map
            .flyTo(mkr.getLatLng(), popupZoomLevel, {duration: 0.75})
            .once('moveend', () => {
              setTimeout(() => {
                _fireEventOnMarkerOrVisibleParentCluster(mkr, 'click');
               }, spiderfyDelay);
               spiderfyDelay = 0;
            });
          } else {
            // Should never get here
            console.log('Error: unable to find the selected marker');
          }
        }
      });
    }

    _drawMap();
    _buildMapData();
    _loadListeners();

  })();
</script>
