<?php
// Base Report Generator
//
// used by the SAX parser to generate reports from the XML report file.
//
// webtrees: Web based Family History software
// Copyright (C) 2014 webtrees development team.
//
// Derived from PhpGedView
// Copyright (C) 2002 to 2009 PGV Development Team.  All rights reserved.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

/**
 * Main Report Class
 *
 * Document wide functions and variable defaults that will be inherited of the report modules
 */
class WT_Report_Base {
	/** User measure unit. */
	const UNITS = 'pt';

	/** webtrees URL */
	const WT_URL = WT_WEBTREES_URL;

	/** @var float Left Margin (expressed in points) Default: 17.99 mm, 0.7083 inch */
	public $leftmargin = 51.0;

	/** @var float Right Margin (expressed in points) Default: 9.87 mm, 0.389 inch */
	public $rightmargin = 28.0;

	/** @var float Top Margin (expressed in points) Default: 26.81 mm */
	public $topmargin = 76.0;

	/** @var float Bottom Margin (expressed in points) Default: 21.6 mm */
	public $bottommargin = 60.0;

	/** @var float Header Margin (expressed in points) Default: 4.93 mm */
	public $headermargin = 14.0;

	/** @var float Footer Margin (expressed in points) Default: 9.88 mm, 0.389 inch */
	public $footermargin = 28.0;

	/** @var string Page orientation (portrait, landscape) */
	public $orientation = 'portrait';

	/** @var string Page format name */
	public $pageFormat = 'A4';

	/** @var float Height of page format in points */
	public $pageh = 0.0;

	/** @var float Width of page format in points */
	public $pagew = 0.0;

	/** @var string[][] An array of the Styles elements found in the document */
	public $Styles = array();

	/** @var string The default Report font name */
	public $defaultFont = 'dejavusans';

	/** @var integer The default Report font size */
	public $defaultFontSize = 12;

	/** @var string Header (H), Page header (PH), Body (B) or Footer (F) */
	public $processing = 'H';

	/** @var boolean RTL Language (false=LTR, true=RTL) */
	public $rtl = false;

	/** @var boolean Show the Generated by... (true=show the text) */
	public $showGenText = true;

	/** @var string Generated By... text */
	public $generatedby = '';

	/** @var string The report title */
	public $title = '';

	/** @var string Author of the report, the users full name */
	public $rauthor = WT_SERVER_NAME;

	/** @var string Keywords */
	public $rkeywords = '';

	/** @var string Report Description / Subject */
	public $rsubject = '';

	/**
	 * Initial Setup - WT_Report_Base
	 *
	 * Setting up document wide defaults that will be inherited of the report modules
	 * As DEFAULT A4 and Portrait will be used if not set
	 *
	 */
	function setup() {
		global $TEXT_DIRECTION;

		// Set RTL direction
		if ($TEXT_DIRECTION == 'rtl') {
			$this->rtl = true;
		}
		// Set the Keywords
		$this->rkeywords = '';
		// Generated By...text
		// I18N: This is a report footer. %s is the name of the application.
		$this->generatedby = WT_I18N::translate('Generated by %s', WT_WEBTREES . ' ' . WT_VERSION);

		// For known size pages
		if ($this->pagew == 0 && $this->pageh == 0) {
			/**
			 * The current ISO 216 standard was introduced in 1975 and is a direct follow up to the german DIN 476 standard from 1922. ISO 216 is also called EN 20216 in Europe.
			 * The ISO paper sizes are based on the metric system so everything else is aproxiamte
			 *
			 * The Series A is used for Standard Printing and Stationary.
			 * The Series B is used for Posters, Wall-Charts etc.
			 * The C series is used for folders, post cards and envelopes. C series envelope is suitable to insert A series sizes.
			 * ISO also define format series RA and SRA for untrimmed raw paper, where SRA stands for 'supplementary raw format A'.
			 * Japan has adopted the ISO series A sizes, but its series B sizes are slightly different. These sizes are sometimes called JIS B or JB sizes.
			 *  sun was a unit of length used in Japan and is equal to about 3.03 cm or 1.193 inches
			 * The United States, Canada, and in part Mexico, are today the only industrialized nations in which the ISO standard paper sizes are not yet widely used.
			 *
			 * A0 & A1        Technical drawings, posters
			 * A1 & A2        Flip charts
			 * A2 & A3        Drawings, diagrams, large tables
			 * A4             Letters, magazines, forms, catalogs, laser printer and copying machine output
			 * A5             Note pads
			 * A6             Postcards
			 * B5, A5, B6  A6 Books
			 * C4, C5, C6     Envelopes for A4 letters: unfolded (C4), folded once (C5), folded twice (C6)
			 * B4 & A3        Newspapers, supported by most copying machines in addition to A4
			 * B8 & A8        Playing cards
			 *
			 * 1 inch = 72 points
			 * 1 mm = 2.8346457 points
			 * 1 inch = 25.4 mm
			 * 1 point = 0,35278 mm
			 */
			switch ($this->pageFormat) {
			// ISO A series
			case '4A0': // ISO 216, 1682 mm x 2378 mm
				$sizes = array(4767.86, 6740.79);
				break;
			case '2A0': // ISO 216, 1189 mm x 1682 mm
				$sizes = array(3370.39, 4767.86);
				break;
			case 'A0': // ISO 216, 841 mm x 1189mm
				$sizes = array(2383.94, 3370.39);
				break;
			case 'A1': // ISO 216, 594 mm x 841 mm
				$sizes = array(1683.78, 2383.94);
				break;
			case 'A2': // ISO 216, 420 mm x 594 mm
				$sizes = array(1190.55, 1683.78);
				break;
			case 'A3': // ISO 216, 297 mm x 420 mm
				$sizes = array(841.89, 1190.55);
				break;
			case 'A4': // ISO 216, 210 mm 297 mm
				$sizes = array(595.28, 841.89);
				break;
			case 'A5': // ISO 216, 148 mm x 210 mm
				$sizes = array(419.53, 595.28);
				break;
			case 'A6': // ISO 216, 105 mm x 148 mm
				$sizes = array(297.64, 419.53);
				break;
			case 'A7': // ISO 216, 74 mm x 105 mm
				$sizes = array(209.76, 297.64);
				break;
			case 'A8': // ISO 216, 52 mm x 74 mm
				$sizes = array(147.40, 209.76);
				break;
			case 'A9': // ISO 216, 37 mm x 52 mm
				$sizes = array(104.88, 147.40);
				break;
			case 'A10': // ISO 216, 26 mm x 37 mm
				$sizes = array(73.70, 104.88);
				break;

			// ISO B series
			case 'B0': // ISO 216, 1000 mm x 1414 mm
				$sizes = array(2834.65, 4008.19);
				break;
			case 'B1': // ISO 216, 707 mm x 1000 mm
				$sizes = array(2004.09, 2834.65);
				break;
			case 'B2': // ISO 216, 500 mm x 707 mm
				$sizes = array(1417.32, 2004.09);
				break;
			case 'B3': // ISO 216, 353 mm x 500 mm
				$sizes = array(1000.63, 1417.32);
				break;
			case 'B4': // ISO 216, 250 mm x 353 mm
				$sizes = array(708.66, 1000.63);
				break;
			case 'B5': // ISO 216, 176 mm x 250 mm
				$sizes = array(498.90, 708.66);
				break;
			case 'B6': // ISO 216, 125 mm x 176 mm
				$sizes = array(354.33, 498.90);
				break;
			case 'B7': // ISO 216, 88 mm x 125 mm
				$sizes = array(249.45, 354.33);
				break;
			case 'B8': // ISO 216, 62 mm x 88 mm
				$sizes = array(175.75, 249.45);
				break;
			case 'B9': // ISO 216, 44 mm x 62 mm
				$sizes = array(124.72, 175.75);
				break;
			case 'B10': // ISO 216, 31 mm x 44 mm
				$sizes = array(87.87, 124.72);
				break;

			// ISO C series, Envelope
			case 'C0': // ISO 269, 917 mm x 1297 mm, For flat A0 sheet
				$sizes = array(2599.37, 3676.54);
				break;
			case 'C1': // ISO 269, 648 mm x 917 mm, For flat A1 sheet
				$sizes = array(1836.85, 2599.37);
				break;
			case 'C2': // ISO 269, 458 mm x 648 mm, For flat A2 sheet, A1 folded in half
				$sizes = array(1298.27, 1836.85);
				break;
			case 'C3': // ISO 269, 324 mm x 458 mm, For flat A3 sheet, A2 folded in half
				$sizes = array(918.43, 1298.27);
				break;
			case 'C4': // ISO 269, 229 mm x 324 mm, For flat A4 sheet, A3 folded in half
				$sizes = array(649.13, 918.43);
				break;
			case 'C5': // ISO 269, 162 mm x 229 mm, For flat A5 sheet, A4 folded in half
				$sizes = array(459.21, 649.13);
				break;
			case 'C6/5': // ISO 269, 114 mm x 229 mm. A5 folded twice = 1/3 A4. Alternative for the DL envelope
				$sizes = array(323.15, 649.13);
				break;
			case 'C6': // ISO 269, 114 mm x 162 mm, For A5 folded in half
				$sizes = array(323.15, 459.21);
				break;
			case 'C7/6': // ISO 269, 81 mm x 162 mm, For A5 sheet folded in thirds
				$sizes = array(229.61, 459.21);
				break;
			case 'C7': // ISO 269, 81 mm x 114 mm, For A5 folded in quarters
				$sizes = array(229.61, 323.15);
				break;
			case 'C8': // ISO 269, 57 mm x 81 mm
				$sizes = array(161.57, 229.61);
				break;
			case 'C9': // ISO 269, 40 mm x 57 mm
				$sizes = array(113.39, 161.57);
				break;
			case 'C10': // ISO 269, 28 mm x 40 mm
				$sizes = array(79.37, 113.39);
				break;
			case 'DL': // Original DIN 678 but ISO 269 now has this C6/5 , 110 mm x 220 mm, For A4 sheet folded in thirds, A5 in half
				$sizes = array(311.81, 623.62);
				break;

			// Untrimmed stock sizes for the ISO-A Series - ISO primary range
			case 'RA0': // ISO 478, 860 mm x 1220 mm
				$sizes = array(2437.80, 3458.27);
				break;
			case 'RA1': // ISO 478, 610 mm x 860 mm
				$sizes = array(1729.13, 2437.80);
				break;
			case 'RA2': // ISO 478, 430 mm x 610 mm
				$sizes = array(1218.90, 1729.13);
				break;
			case 'RA3': // ISO 478, 305 mm x 430 mm
				$sizes = array(864.57, 1218.90);
				break;
			case 'RA4': // ISO 478, 215 mm x 305 mm
				$sizes = array(609.45, 864.57);
				break;

			// Untrimmed stock sizes for the ISO-A Series - ISO supplementary range
			case 'SRA0': // ISO 593, 900 mm x 1280 mm
				$sizes = array(2551.18, 3628.35);
				break;
			case 'SRA1': // ISO 593, 640 mm x 900 mm
				$sizes = array(1814.17, 2551.18);
				break;
			case 'SRA2': // ISO 593, 450 mm x 640 mm
				$sizes = array(1275.59, 1814.17);
				break;
			case 'SRA3': // ISO 593, 320 mm x 450 mm
				$sizes = array(907.09, 1275.59);
				break;
			case 'SRA4': // ISO 593, 225 mm x 320 mm
				$sizes = array(637.80, 907.09);
				break;

			// ISO size variations
			case 'A2EXTRA': // ISO 216, 445 mm x 619 mm
				$sizes = array(1261.42, 1754.65);
				break;
			case 'A2SUPER': // ISO 216, 305 mm x 508 mm
				$sizes = array(864.57, 1440.00);
				break;
			case 'A3EXTRA': // ISO 216, 322 mm x 445 mm
				$sizes = array(912.76, 1261.42);
				break;
			case 'SUPERA3': // ISO 216, 305 mm x 487 mm
				$sizes = array(864.57, 1380.47);
				break;
			case 'A4EXTRA': // ISO 216, 235 mm x 322 mm
				$sizes = array(666.14, 912.76);
				break;
			case 'A4LONG': // ISO 216, 210 mm x 348 mm
				$sizes = array(595.28, 986.46);
				break;
			case 'A4SUPER': // ISO 216, 229 mm x 322 mm
				$sizes = array(649.13, 912.76);
				break;
			case 'SUPERA4': // ISO 216, 227 mm x 356 mm
				$sizes = array(643.46, 1009.13);
				break;
			case 'A5EXTRA': // ISO 216, 173 mm x 235 mm
				$sizes = array(490.39, 666.14);
				break;
			case 'SOB5EXTRA': // ISO 216, 202 mm x 276 mm
				$sizes = array(572.60, 782.36);
				break;

			// Japanese version of the ISO 216 B series
			case 'JB0': // JIS P 0138-61, 1030 mm x 1456 mm
				$sizes = array(2919.69, 4127.24);
				break;
			case 'JB1': // JIS P 0138-61, 728 mm x 1030 mm
				$sizes = array(2063.62, 2919.69);
				break;
			case 'JB2': // JIS P 0138-61, 515 mm x 728 mm
				$sizes = array(1459.84, 2063.62);
				break;
			case 'JB3': // JIS P 0138-61, 364 mm x 515 mm
				$sizes = array(1031.81, 1459.84);
				break;
			case 'JB4': // JIS P 0138-61, 257 mm x 364 mm
				$sizes = array(728.50, 1031.81);
				break;
			case 'JB5': // JIS P 0138-61, 182 mm x 257 mm
				$sizes = array(515.91, 728.50);
				break;
			case 'JB6': // JIS P 0138-61, 128 mm x 182 mm
				$sizes = array(362.83, 515.91);
				break;
			case 'JB7': // JIS P 0138-61, 91 mm x 128 mm
				$sizes = array(257.95, 362.83);
				break;
			case 'JB8': // JIS P 0138-61, 64 mm x 91 mm
				$sizes = array(181.42, 257.95);
				break;
			case 'JB9': // JIS P 0138-61, 45 mm x 64 mm
				$sizes = array(127.56, 181.42);
				break;
			case 'JB10': // JIS P 0138-61, 32 mm x 45 mm
				$sizes = array(90.71, 127.56);
				break;

			// US pages
			case 'EXECUTIVE': // 7.25 in x 10.5 in
				$sizes = array(522.00, 756.00);
				break;
			case 'FOLIO': // 8.5 in x 13 in
				$sizes = array(612.00, 936.00);
				break;
			case 'FOOLSCAP': // 13.5 in x 17 in
				$sizes = array(972.00, 1224.00);
				break;
			case 'LEDGER': // 11 in x 17 in
				$sizes = array(792.00, 1224.00);
				break;
			case 'LEGAL': // 8.5 in x 14 in
				$sizes = array(612.00, 1008.00);
				break;
			case 'LETTER': // 8.5 in x 11 in
				$sizes = array(612.00, 792.00);
				break;
			case 'QUARTO': // 8.46 in x 10.8 in
				$sizes = array(609.12, 777.50);
				break;
			case 'STATEMENT': // 5.5 in x 8.5 in
				$sizes = array(396.00, 612.00);
				break;
			case 'USGOVT': // 8 in x 11 in
				$sizes = array(576.00, 792.00);
				break;
			default:
				$this->pageFormat = 'A4';
				$sizes = array(595.28, 841.89);
				break;
			}
			$this->pagew = $sizes[0];
			$this->pageh = $sizes[1];
		} else {
			if ($this->pagew < 10) {
				die("<strong>REPORT ERROR WT_Report_Base::setup(): </strong>For custom size pages you must set \"customwidth\" larger then this in the XML file");
			}
			if ($this->pageh < 10) {
				die("<strong>REPORT ERROR WT_Report_Base::setup(): </strong>For custom size pages you must set \"customheight\" larger then this in the XML file");
			}
		}

		return 0;
	}

	/**
	 * Process the Header , Page header, Body or Footer - WT_Report_Base
	 *
	 * @param string $p Header (H), Page header (PH), Body (B) or Footer (F)
	 *
	 * @return integer
	 */
	function setProcessing($p) {
		$this->processing = $p;

		return 0;
	}

	/**
	 * Add the Title when raw character data is used in Title - WT_Report_Base
	 *
	 * @param string $data
	 *
	 * @return integer
	 */
	function addTitle($data) {
		$this->title .= $data;

		return 0;
	}

	/**
	 * Add the Description when raw character data is used in Description - WT_Report_Base
	 *
	 * @param string $data
	 *
	 * @return integer
	 */
	function addDescription($data) {
		$this->rsubject .= $data;

		return 0;
	}

	/**
	 * Add Style to Styles array - WT_Report_Base
	 *
	 * @param array $style
	 *
	 * @return integer
	 */
	function addStyle($style) {
		$this->Styles[$style['name']] = $style;

		return 0;
	}

	/**
	 * Get a style from the Styles array - WT_Report_Base
	 *
	 * @param string $s Style name
	 *
	 * @return array
	 */
	function getStyle($s) {
		if (!isset($this->Styles[$s])) {
			return current($this->Styles);
		}

		return $this->Styles[$s];
	}
}

/**
 *XML start element handler
 *
 * This function is called whenever a starting element is reached
 * The element handler will be called if found, otherwise it must be HTML
 *
 * @param resource $parser the resource handler for the XML parser
 * @param string   $name   the name of the XML element parsed
 * @param array    $attrs  an array of key value pairs for the attributes
 *
 */
function startElement($parser, $name, $attrs) {
	global $elementHandler, $processIfs, $processGedcoms, $processRepeats, $vars;
	global $processFootnote;

	$newattrs = array();

	foreach ($attrs as $key => $value) {
		if (preg_match("/^\\$(\w+)$/", $value, $match)) {
			if ((isset($vars[$match[1]]['id'])) && (!isset($vars[$match[1]]['gedcom']))) {
				$value = $vars[$match[1]]['id'];
			}
		}
		$newattrs[$key] = $value;
	}
	$attrs = $newattrs;
	if (($processFootnote) && ($processIfs == 0 || $name == "if") && ($processGedcoms == 0 || $name == "Gedcom") && ($processRepeats == 0 || $name == "Facts" || $name == "RepeatTag")) {
		if (isset($elementHandler[$name]['start'])) {
			if ($elementHandler[$name]['start'] != "") {
				call_user_func($elementHandler[$name]['start'], $attrs);
			}
		} elseif (!isset($elementHandler[$name]['end'])) {
			htmlStartHandler($name, $attrs);
		}
	}
}

/**
 * XML end element handler
 *
 * This function is called whenever an ending element is reached
 * The element handler will be called if found, otherwise it must be HTML
 *
 * @param resource $parser the resource handler for the XML parser
 * @param string   $name   the name of the XML element parsed
 *
 */
function endElement($parser, $name) {
	global $elementHandler, $processIfs, $processGedcoms, $processRepeats;
	global $processFootnote;

	if (($processFootnote || $name == "Footnote") && ($processIfs == 0 || $name == "if") && ($processGedcoms == 0 || $name == "Gedcom") && ($processRepeats == 0 || $name == "Facts" || $name == "RepeatTag" || $name == "List" || $name == "Relatives")) {
		if (isset($elementHandler[$name]['end'])) {
			if ($elementHandler[$name]['end'] != "") {
				call_user_func($elementHandler[$name]['end']);
			}
		} elseif (!isset($elementHandler[$name]['start'])) {
			htmlEndHandler($name);
		}
	}
}

/**
 * XML character data handler
 *
 * This function is called whenever raw character data is reached
 * just print it to the screen
 *
 * @param resource $parser the resource handler for the XML parser
 * @param string   $data   the name of the XML element parsed
 */
function characterData($parser, $data) {
	global $printData, $currentElement, $processGedcoms, $processIfs, $processRepeats, $reportTitle, $wt_report, $reportDescription;

	if ($printData && ($processGedcoms == 0) && ($processIfs == 0) && ($processRepeats == 0)) {
		$currentElement->addText($data);
	} elseif ($reportTitle) {
		$wt_report->addTitle($data);
	} elseif ($reportDescription) {
		$wt_report->addDescription($data);
	}
}

/**
 * XML <style> start element handler
 *
 * @param array $attrs an array of key value pairs for the attributes
 */
function styleStartHandler($attrs) {
	global $wt_report;

	if (empty($attrs['name'])) {
		die("<strong>REPORT ERROR Style: </strong> The \"name\" of the style is missing or not set in the XML file.");
	}

	// array Style that will be passed on
	$s = array();

	// string Name af the style
	$s['name'] = $attrs['name'];

	// string Name of the DEFAULT font
	$s['font'] = $wt_report->defaultFont;
	if (!empty($attrs['font'])) {
		$s['font'] = $attrs['font'];
	}

	// int The size of the font in points
	$s['size'] = $wt_report->defaultFontSize;
	if (!empty($attrs['size'])) {
		$s['size'] = (int)$attrs['size'];
	} // Get it as int to ignore all decimal points or text (if any text then int(0))

	// string B: bold, I: italic, U: underline, D: line trough, The default value is regular.
	$s['style'] = "";
	if (!empty($attrs['style'])) {
		$s['style'] = $attrs['style'];
	}

	$wt_report->addStyle($s);
}

/**
 * XML <Doc> start element handler
 *
 * Sets up the basics of the document proparties
 *
 * @param array $attrs an array of key value pairs for the attributes
 */
function docStartHandler($attrs) {
	global $parser, $xml_parser, $wt_report;

	$parser = $xml_parser;

	// Custom page width
	if (!empty($attrs['customwidth'])) {
		$wt_report->pagew = (int)$attrs['customwidth'];
	} // Get it as int to ignore all decimal points or text (if any text then int(0))
	// Custom Page height
	if (!empty($attrs['customheight'])) {
		$wt_report->pageh = (int)$attrs['customheight'];
	} // Get it as int to ignore all decimal points or text (if any text then int(0))

	// Left Margin
	if (isset($attrs['leftmargin'])) {
		if ($attrs['leftmargin'] === "0") {
			$wt_report->leftmargin = 0;
		} elseif (!empty($attrs['leftmargin'])) {
			$wt_report->leftmargin = (int)$attrs['leftmargin']; // Get it as int to ignore all decimal points or text (if any text then int(0))
		}
	}
	// Right Margin
	if (isset($attrs['rightmargin'])) {
		if ($attrs['rightmargin'] === "0") {
			$wt_report->rightmargin = 0;
		} elseif (!empty($attrs['rightmargin'])) {
			$wt_report->rightmargin = (int)$attrs['rightmargin']; // Get it as int to ignore all decimal points or text (if any text then int(0))
		}
	}
	// Top Margin
	if (isset($attrs['topmargin'])) {
		if ($attrs['topmargin'] === "0") {
			$wt_report->topmargin = 0;
		} elseif (!empty($attrs['topmargin'])) {
			$wt_report->topmargin = (int)$attrs['topmargin']; // Get it as int to ignore all decimal points or text (if any text then int(0))
		}
	}
	// Bottom Margin
	if (isset($attrs['bottommargin'])) {
		if ($attrs['bottommargin'] === "0") {
			$wt_report->bottommargin = 0;
		} elseif (!empty($attrs['bottommargin'])) {
			$wt_report->bottommargin = (int)$attrs['bottommargin']; // Get it as int to ignore all decimal points or text (if any text then int(0))
		}
	}
	// Header Margin
	if (isset($attrs['headermargin'])) {
		if ($attrs['headermargin'] === "0") {
			$wt_report->headermargin = 0;
		} elseif (!empty($attrs['headermargin'])) {
			$wt_report->headermargin = (int)$attrs['headermargin']; // Get it as int to ignore all decimal points or text (if any text then int(0))
		}
	}
	// Footer Margin
	if (isset($attrs['footermargin'])) {
		if ($attrs['footermargin'] === "0") {
			$wt_report->footermargin = 0;
		} elseif (!empty($attrs['footermargin'])) {
			$wt_report->footermargin = (int)$attrs['footermargin']; // Get it as int to ignore all decimal points or text (if any text then int(0))
		}
	}

	// Page Orientation
	if (!empty($attrs['orientation'])) {
		if ($attrs['orientation'] == "landscape") {
			$wt_report->orientation = "landscape";
		} elseif ($attrs['orientation'] == "portrait") {
			$wt_report->orientation = "portrait";
		}
	}
	// Page Size
	if (!empty($attrs['pageSize'])) {
		$wt_report->pageFormat = strtoupper($attrs['pageSize']);
	}

	// Show Generated By...
	if (isset($attrs['showGeneratedBy'])) {
		if ($attrs['showGeneratedBy'] === "0") {
			$wt_report->showGenText = false;
		} elseif ($attrs['showGeneratedBy'] === "1") {
			$wt_report->showGenText = true;
		}
	}

	$wt_report->setup();
}

/**
 * XML </Doc> end element handler
 */
function docEndHandler() {
	global $wt_report;
	$wt_report->run();
}

/**
 * XML <Header> start element handler
 */
function headerStartHandler() {
	global $wt_report;

	// Clear the Header before any new elements are added
	$wt_report->clearHeader();
	$wt_report->setProcessing("H");
}

/**
 * XML <PageHeader> start element handler
 */
function pageHeaderStartHandler() {
	global $printDataStack, $printData, $wt_reportStack, $wt_report, $ReportRoot;

	array_push($printDataStack, $printData);
	$printData = false;
	array_push($wt_reportStack, $wt_report);
	$wt_report = $ReportRoot->createPageHeader();
}

/**
 * XML <pageHeaderEndHandler> end element handler
 */
function pageHeaderEndHandler() {
	global $printData, $printDataStack, $wt_report, $currentElement, $wt_reportStack;

	$printData = array_pop($printDataStack);
	$currentElement = $wt_report;
	$wt_report = array_pop($wt_reportStack);
	$wt_report->addElement($currentElement);
}

/**
 * XML <bodyStartHandler> start element handler
 */
function bodyStartHandler() {
	global $wt_report;
	$wt_report->setProcessing("B");
}

/**
 * XML <footerStartHandler> start element handler
 */
function footerStartHandler() {
	global $wt_report;
	$wt_report->setProcessing("F");
}

/**
 * XML <Cell> start element handler
 *
 * @param array $attrs an array of key value pairs for the attributes
 */
function cellStartHandler($attrs) {
	global $printData, $printDataStack, $currentElement, $ReportRoot, $wt_report;

	// string The text alignment of the text in this box.
	$align = "";
	if (!empty($attrs['align'])) {
		$align = $attrs['align'];
		// RTL supported left/right alignment
		if ($align == "rightrtl") {
			if ($wt_report->rtl) {
				$align = "left";
			} else {
				$align = "right";
			}
		} elseif ($align == "leftrtl") {
			if ($wt_report->rtl) {
				$align = "right";
			} else {
				$align = "left";
			}
		}
	}

	// string The color to fill the background of this cell
	$bgcolor = "";
	if (!empty($attrs['bgcolor'])) {
		$bgcolor = $attrs['bgcolor'];
	}

	// int Whether or not the background should be painted
	$fill = 1;
	if (isset($attrs['fill'])) {
		if ($attrs['fill'] === "0") {
			$fill = 0;
		} elseif ($attrs['fill'] === "1") {
			$fill = 1;
		}
	}

	$reseth = true;
	// boolean   if true reset the last cell height (default true)
	if (isset($attrs['reseth'])) {
		if ($attrs['reseth'] === "0") {
			$reseth = false;
		} elseif ($attrs['reseth'] === "1") {
			$reseth = true;
		}
	}

	// mixed Whether or not a border should be printed around this box
	$border = 0;
	if (!empty($attrs['border'])) {
		$border = $attrs['border'];
	}
	// string Border color in HTML code
	$bocolor = "";
	if (!empty($attrs['bocolor'])) {
		$bocolor = $attrs['bocolor'];
	}

	// int Cell height (expressed in points) The starting height of this cell. If the text wraps the height will automatically be adjusted.
	$height = 0;
	if (!empty($attrs['height'])) {
		$height = (int)$attrs['height'];
	}
	// int Cell width (expressed in points) Setting the width to 0 will make it the width from the current location to the right margin.
	$width = 0;
	if (!empty($attrs['width'])) {
		$width = (int)$attrs['width'];
	}

	// int Stretch carachter mode
	$stretch = 0;
	if (!empty($attrs['stretch'])) {
		$stretch = (int)$attrs['stretch'];
	}

	// mixed Position the left corner of this box on the page. The default is the current position.
	$left = ".";
	if (isset($attrs['left'])) {
		if ($attrs['left'] === ".") {
			$left = ".";
		} elseif (!empty($attrs['left'])) {
			$left = (int)$attrs['left'];
		} elseif ($attrs['left'] === "0") {
			$left = 0;
		}
	}
	// mixed Position the top corner of this box on the page. the default is the current position
	$top = ".";
	if (isset($attrs['top'])) {
		if ($attrs['top'] === ".") {
			$top = ".";
		} elseif (!empty($attrs['top'])) {
			$top = (int)$attrs['top'];
		} elseif ($attrs['top'] === "0") {
			$top = 0;
		}
	}

	// string The name of the Style that should be used to render the text.
	$style = "";
	if (!empty($attrs['style'])) {
		$style = $attrs['style'];
	}

	// string Text color in html code
	$tcolor = "";
	if (!empty($attrs['tcolor'])) {
		$tcolor = $attrs['tcolor'];
	}

	// int Indicates where the current position should go after the call.
	$ln = 0;
	if (isset($attrs['newline'])) {
		if (!empty($attrs['newline'])) {
			$ln = (int)$attrs['newline'];
		} elseif ($attrs['newline'] === "0") {
			$ln = 0;
		}
	}

	if ($align == "left") {
		$align = "L";
	} elseif ($align == "right") {
		$align = "R";
	} elseif ($align == "center") {
		$align = "C";
	} elseif ($align == "justify") {
		$align = "J";
	}

	array_push($printDataStack, $printData);
	$printData = true;

	$currentElement = $ReportRoot->createCell(
		$width,
		$height,
		$border,
		$align,
		$bgcolor,
		$style,
		$ln,
		$top,
		$left,
		$fill,
		$stretch,
		$bocolor,
		$tcolor,
		$reseth
	);
}

/**
 * XML </Cell> end element handler
 */
function cellEndHandler() {
	global $printData, $printDataStack, $currentElement, $wt_report;

	$printData = array_pop($printDataStack);
	$wt_report->addElement($currentElement);
}

/**
 * XML <Now /> element handler
 */
function nowStartHandler() {
	global $currentElement;

	$g = timestamp_to_gedcom_date(WT_CLIENT_TIMESTAMP);
	$currentElement->addText($g->display());
}

/**
 * XML <PageNum /> element handler
 */
function pageNumStartHandler() {
	global $currentElement;
	$currentElement->addText("#PAGENUM#");
}

/**
 * XML <TotalPages /> element handler
 */
function totalPagesStartHandler() {
	global $currentElement;
	$currentElement->addText("{{:ptp:}}");
}

/**
 * Called at the start of an element.
 *
 * @param array $attrs an array of key value pairs for the attributes
 *
 * @return void
 */
function gedcomStartHandler($attrs) {
	global $vars, $gedrec, $gedrecStack, $processGedcoms, $fact, $desc, $ged_level;

	if ($processGedcoms > 0) {
		$processGedcoms++;

		return;
	}

	$tag = $attrs['id'];
	$tag = str_replace("@fact", $fact, $tag);
	$tags = explode(":", $tag);
	$newgedrec = "";
	if (count($tags) < 2) {
		$tmp = WT_GedcomRecord::getInstance($attrs['id']);
		$newgedrec = $tmp ? $tmp->privatizeGedcom(WT_USER_ACCESS_LEVEL) : '';
	}
	if (empty($newgedrec)) {
		$tgedrec = $gedrec;
		$newgedrec = "";
		foreach ($tags as $tag) {
			if (preg_match("/\\$(.+)/", $tag, $match)) {
				if (isset($vars[$match[1]]['gedcom'])) {
					$newgedrec = $vars[$match[1]]['gedcom'];
				} else {
					$tmp = WT_GedcomRecord::getInstance($match[1]);
					$newgedrec = $tmp ? $tmp->privatizeGedcom(WT_USER_ACCESS_LEVEL) : '';
				}
			} else {
				if (preg_match("/@(.+)/", $tag, $match)) {
					$gmatch = array();
					if (preg_match("/\d $match[1] @([^@]+)@/", $tgedrec, $gmatch)) {
						$tmp = WT_GedcomRecord::getInstance($gmatch[1]);
						$newgedrec = $tmp ? $tmp->privatizeGedcom(WT_USER_ACCESS_LEVEL) : '';
						$tgedrec = $newgedrec;
					} else {
						$newgedrec = "";
						break;
					}
				} else {
					$temp = explode(" ", trim($tgedrec));
					$level = $temp[0] + 1;
					$newgedrec = get_sub_record($level, "$level $tag", $tgedrec);
					$tgedrec = $newgedrec;
				}
			}
		}
	}
	if (!empty($newgedrec)) {
		array_push($gedrecStack, array($gedrec, $fact, $desc));
		$gedrec = $newgedrec;
		if (preg_match("/(\d+) (_?[A-Z0-9]+) (.*)/", $gedrec, $match)) {
			$ged_level = $match[1];
			$fact = $match[2];
			$desc = trim($match[3]);
		}
	} else {
		$processGedcoms++;
	}
}

/**
 * Called at the end of an element.
 *
 * @return void
 */
function gedcomEndHandler() {
	global $gedrec, $gedrecStack, $processGedcoms, $fact, $desc;

	if ($processGedcoms > 0) {
		$processGedcoms--;
	} else {
		$temp = array_pop($gedrecStack);
		$gedrec = $temp[0];
		$fact = $temp[1];
		$desc = $temp[2];
	}
}

/**
 * XML <textBoxStartHandler> start element handler
 *
 * @param array $attrs an array of key value pairs for the attributes
 */
function textBoxStartHandler($attrs) {
	global $printData, $printDataStack, $wt_report, $wt_reportStack, $ReportRoot;

	// string Background color code
	$bgcolor = "";
	if (!empty($attrs['bgcolor'])) {
		$bgcolor = $attrs['bgcolor'];
	}

	// boolean Wether or not fill the background color
	$fill = true;
	if (isset($attrs['fill'])) {
		if ($attrs['fill'] === "0") {
			$fill = false;
		} elseif ($attrs['fill'] === "1") {
			$fill = true;
		}
	}

	// var boolean Whether or not a border should be printed around this box. 0 = no border, 1 = border. Default is 0
	$border = false;
	if (isset($attrs['border'])) {
		if ($attrs['border'] === "1") {
			$border = true;
		} elseif ($attrs['border'] === "0") {
			$border = false;
		}
	}

	// int The starting height of this cell. If the text wraps the height will automatically be adjusted
	$height = 0;
	if (!empty($attrs['height'])) {
		$height = (int)$attrs['height'];
	}
	// int Setting the width to 0 will make it the width from the current location to the margin
	$width = 0;
	if (!empty($attrs['width'])) {
		$width = (int)$attrs['width'];
	}

	// mixed Position the left corner of this box on the page. The default is the current position.
	$left = ".";
	if (isset($attrs['left'])) {
		if ($attrs['left'] === ".") {
			$left = ".";
		} elseif (!empty($attrs['left'])) {
			$left = (int)$attrs['left'];
		} elseif ($attrs['left'] === "0") {
			$left = 0;
		}
	}
	// mixed Position the top corner of this box on the page. the default is the current position
	$top = ".";
	if (isset($attrs['top'])) {
		if ($attrs['top'] === ".") {
			$top = ".";
		} elseif (!empty($attrs['top'])) {
			$top = (int)$attrs['top'];
		} elseif ($attrs['top'] === "0") {
			$top = 0;
		}
	}
	// boolean After this box is finished rendering, should the next section of text start immediately after the this box or should it start on a new line under this box. 0 = no new line, 1 = force new line. Default is 0
	$newline = false;
	if (isset($attrs['newline'])) {
		if ($attrs['newline'] === "1") {
			$newline = true;
		} elseif ($attrs['newline'] === "0") {
			$newline = false;
		}
	}
	// boolean
	$pagecheck = true;
	if (isset($attrs['pagecheck'])) {
		if ($attrs['pagecheck'] === "0") {
			$pagecheck = false;
		} elseif ($attrs['pagecheck'] === "1") {
			$pagecheck = true;
		}
	}
	// boolean Cell padding
	$padding = true;
	if (isset($attrs['padding'])) {
		if ($attrs['padding'] === "0") {
			$padding = false;
		} elseif ($attrs['padding'] === "1") {
			$padding = true;
		}
	}
	// boolean Reset this box Height
	$reseth = false;
	if (isset($attrs['reseth'])) {
		if ($attrs['reseth'] === "1") {
			$reseth = true;
		} elseif ($attrs['reseth'] === "0") {
			$reseth = false;
		}
	}

	// string Style of rendering
	$style = "";

	array_push($printDataStack, $printData);
	$printData = false;

	array_push($wt_reportStack, $wt_report);
	$wt_report = $ReportRoot->createTextBox(
		$width,
		$height,
		$border,
		$bgcolor,
		$newline,
		$left,
		$top,
		$pagecheck,
		$style,
		$fill,
		$padding,
		$reseth
	);
}

/**
 * XML <textBoxEndHandler> end element handler
 */
function textBoxEndHandler() {
	global $printData, $printDataStack, $wt_report, $currentElement, $wt_reportStack;

	$printData = array_pop($printDataStack);
	$currentElement = $wt_report;
	$wt_report = array_pop($wt_reportStack);
	$wt_report->addElement($currentElement);
}

/**
 * @param array $attrs an array of key value pairs for the attributes
 */
function textStartHandler($attrs) {
	global $printData, $printDataStack, $currentElement, $ReportRoot;

	array_push($printDataStack, $printData);
	$printData = true;

	// string The name of the Style that should be used to render the text.
	$style = "";
	if (!empty($attrs['style'])) {
		$style = $attrs['style'];
	}

	// string  The color of the text - Keep the black color as default
	$color = "";
	if (!empty($attrs['color'])) {
		$color = $attrs['color'];
	}

	$currentElement = $ReportRoot->createText($style, $color);
}

/**
 *
 */
function textEndHandler() {
	global $printData, $printDataStack, $wt_report, $currentElement;

	$printData = array_pop($printDataStack);
	$wt_report->addElement($currentElement);
}

/**
 * XML <GetPersonName> start element handler
 * Get the name
 * 1. id is empty - current GEDCOM record
 * 2. id is set with a record id
 *
 * @param array $attrs an array of key value pairs for the attributes
 */
function getPersonNameStartHandler($attrs) {
	// @deprecated
	global $currentElement, $vars, $gedrec;

	$id = "";
	$match = array();
	if (empty($attrs['id'])) {
		if (preg_match("/0 @(.+)@/", $gedrec, $match)) {
			$id = $match[1];
		}
	} else {
		if (preg_match("/\\$(.+)/", $attrs['id'], $match)) {
			if (isset($vars[$match[1]]['id'])) {
				$id = $vars[$match[1]]['id'];
			}
		} else {
			if (preg_match("/@(.+)/", $attrs['id'], $match)) {
				$gmatch = array();
				if (preg_match("/\d $match[1] @([^@]+)@/", $gedrec, $gmatch)) {
					$id = $gmatch[1];
				}
			} else {
				$id = $attrs['id'];
			}
		}
	}
	if (!empty($id)) {
		$record = WT_GedcomRecord::getInstance($id);
		if (is_null($record)) {
			return;
		}
		if (!$record->canShowName()) {
			$currentElement->addText(WT_I18N::translate('Private'));
		} else {
			$name = $record->getFullName();
			$name = preg_replace(
				array('/<span class="starredname">/', '/<\/span><\/span>/', '/<\/span>/'),
				array('«', '', '»'),
				$name
			);
			$name = strip_tags($name);
			if (!empty($attrs['truncate'])) {
				if (mb_strlen($name) > $attrs['truncate']) {
					$name = preg_replace("/\(.*\) ?/", '', $name); //removes () and text inbetween - what about ", [ and { etc?
					$words = preg_split('/[, -]+/', $name); // names separated with space, comma or hyphen - any others?
					$name = $words[count($words) - 1];
					for ($i = count($words) - 2; $i >= 0; $i--) {
						$len = mb_strlen($name);
						for ($j = count($words) - 3; $j >= 0; $j--) {
							$len += mb_strlen($words[$j]);
						}
						if ($len > $attrs['truncate']) {
							$first_letter = mb_substr($words[$i], 0, 1);
							// Do not show " of nick-names
							if ($first_letter != "\"") {
								$name = mb_substr($words[$i], 0, 1) . '. ' . $name;
							}
						} else {
							$name = $words[$i] . ' ' . $name;
						}
					}
				}
			} else {
				$addname = $record->getAddName();
				$addname = preg_replace(
					array('/<span class="starredname">/', '/<\/span><\/span>/', '/<\/span>/'),
					array('«', '', '»'),
					$addname
				);
				$addname = strip_tags($addname);
				if (!empty($addname)) {
					$name .= " " . $addname;
				}
			}
			$currentElement->addText(trim($name));
		}
	}
}

/**
 * XML <GedcomValue> start element handler
 *
 * @param array $attrs an array of key value pairs for the attributes
 */
function gedcomValueStartHandler($attrs) {
	// @deprecated
	global $currentElement, $gedrec, $fact, $desc;

	$id = "";
	$match = array();
	if (preg_match("/0 @(.+)@/", $gedrec, $match)) {
		$id = $match[1];
	}

	if (isset($attrs['newline']) && $attrs['newline'] == "1") {
		$useBreak = "1";
	} else {
		$useBreak = "0";
	}

	$tag = $attrs['tag'];
	if (!empty($tag)) {
		if ($tag == "@desc") {
			$value = $desc;
			$value = trim($value);
			$currentElement->addText($value);
		}
		if ($tag == "@id") {
			$currentElement->addText($id);
		} else {
			$tag = str_replace("@fact", $fact, $tag);
			if (empty($attrs['level'])) {
				$temp = explode(" ", trim($gedrec));
				$level = $temp[0];
				if ($level == 0) {
					$level++;
				}
			} else {
				$level = $attrs['level'];
			}
			$tags = preg_split('/[: ]/', $tag);
			$value = get_gedcom_value($tag, $level, $gedrec);
			switch (end($tags)) {
			case 'DATE':
				$tmp = new WT_Date($value);
				$value = $tmp->display();
				break;
			case 'PLAC':
				$tmp = new WT_Place($value, WT_GED_ID);
				$value = $tmp->getShortName();
				break;
			}
			if ($useBreak == "1") {
				// Insert <br> when multiple dates exist.
				// This works around a TCPDF bug that incorrectly wraps RTL dates on LTR pages
				$value = str_replace('(', '<br>(', $value);
				$value = str_replace('<span dir="ltr"><br>', '<br><span dir="ltr">', $value);
				$value = str_replace('<span dir="rtl"><br>', '<br><span dir="rtl">', $value);
				if (substr($value, 0, 6) == '<br>') {
					$value = substr($value, 6);
				}
			}
			$currentElement->addText($value);
		}
	}
}

/**
 * XML <RepeatTag> start element handler
 *
 * @param array $attrs an array of key value pairs for the attributes
 */
function repeatTagStartHandler($attrs) {
	// @deprecated
	global $repeats, $repeatsStack, $gedrec, $repeatBytes, $parser, $processRepeats, $fact, $desc;

	$processRepeats++;
	if ($processRepeats > 1) {
		return;
	}

	array_push($repeatsStack, array($repeats, $repeatBytes));
	$repeats = array();
	$repeatBytes = xml_get_current_line_number($parser);

	$tag = "";
	if (isset($attrs['tag'])) {
		$tag = $attrs['tag'];
	}
	if (!empty($tag)) {
		if ($tag == "@desc") {
			$value = $desc;
			$value = trim($value);
			$currentElement->addText($value);
		} else {
			$tag = str_replace("@fact", $fact, $tag);
			$tags = explode(":", $tag);
			$temp = explode(" ", trim($gedrec));
			$level = $temp[0];
			if ($level == 0) {
				$level++;
			}
			$subrec = $gedrec;
			$t = $tag;
			$count = count($tags);
			$i = 0;
			while ($i < $count) {
				$t = $tags[$i];
				if (!empty($t)) {
					if ($i < ($count - 1)) {
						$subrec = get_sub_record($level, "$level $t", $subrec);
						if (empty($subrec)) {
							$level--;
							$subrec = get_sub_record($level, "@ $t", $gedrec);
							if (empty($subrec)) {
								return;
							}
						}
					}
					$level++;
				}
				$i++;
			}
			$level--;
			$count = preg_match_all("/$level $t(.*)/", $subrec, $match, PREG_SET_ORDER);
			$i = 0;
			while ($i < $count) {
				$repeats[] = get_sub_record($level, "$level $t", $subrec, $i + 1);;
				$i++;
			}
		}
	}
}

/**
 * XML </ RepeatTag> end element handler
 */
function repeatTagEndHandler() {
	global $processRepeats, $repeats, $repeatsStack, $repeatBytes;

	$processRepeats--;
	if ($processRepeats > 0) {
		return;
	}

	// Check if there is anything to repeat
	if (count($repeats) > 0) {
		// No need to load them if not used...
		global $parser, $parserStack, $report, $gedrec;

		$lineoffset = 0;
		foreach ($repeatsStack as $rep) {
			$lineoffset += $rep[1];
		}
		//-- read the xml from the file
		$lines = file($report);
		while (strpos($lines[$lineoffset + $repeatBytes], "<RepeatTag") === false) {
			$lineoffset--;
		}
		$lineoffset++;
		$reportxml = "<tempdoc>\n";
		$line_nr = $lineoffset + $repeatBytes;
		// RepeatTag Level counter
		$count = 1;
		while (0 < $count) {
			if (strstr($lines[$line_nr], "<RepeatTag") !== false) {
				$count++;
			} elseif (strstr($lines[$line_nr], "</RepeatTag") !== false) {
				$count--;
			}
			if (0 < $count) {
				$reportxml .= $lines[$line_nr];
			}
			$line_nr++;
		}
		// No need to drag this
		unset($lines);
		$reportxml .= "</tempdoc>\n";
		// Save original values
		array_push($parserStack, $parser);
		$oldgedrec = $gedrec;
		foreach ($repeats as $gedrec) {
			//-- start the sax parser
			$repeat_parser = xml_parser_create();
			$parser = $repeat_parser;
			//-- make sure everything is case sensitive
			xml_parser_set_option($repeat_parser, XML_OPTION_CASE_FOLDING, false);
			//-- set the main element handler functions
			xml_set_element_handler($repeat_parser, "startElement", "endElement");
			//-- set the character data handler
			xml_set_character_data_handler($repeat_parser, "characterData");
			if (!xml_parse($repeat_parser, $reportxml, true)) {
				printf(
					$reportxml . "\nRepeatTagEHandler XML error: %s at line %d",
					xml_error_string(xml_get_error_code($repeat_parser)),
					xml_get_current_line_number($repeat_parser)
				);
				exit;
			}
			xml_parser_free($repeat_parser);
		}
		// Restore original values
		$gedrec = $oldgedrec;
		$parser = array_pop($parserStack);
	}
	$temp = array_pop($repeatsStack);
	$repeats = $temp[0];
	$repeatBytes = $temp[1];
}

/**
 * Variable lookup
 *
 * Retrieve predefined variables :
 * @ desc GEDCOM fact description, example:
 *        1 EVEN This is a description
 * @ fact GEDCOM fact tag, such as BIRT, DEAT etc.
 * $ WT_I18N::translate('....')
 * $ language_settings[]
 *
 *
 * Or retrieve variables preset with <SetVar> element
 *
 * If the variable is a date and 'date="1"' attribute is set then the date will be reformated
 * from Sep to September
 *
 * @param array $attrs an array of key value pairs for the attributes
 */
function varStartHandler($attrs) {
	// @deprecated
	global $currentElement, $type, $parser;
	// Retrievable variables
	global $desc, $fact, $vars;

	if (empty($attrs['var'])) {
		die("<strong>REPORT ERROR var: </strong> The attribute \"var=\" is missing or not set in the XML file on line: " . xml_get_current_line_number(
				$parser
			));
	}

	$var = $attrs['var'];
	// SetVar element preset variables
	if (!empty($vars[$var]['id'])) {
		$var = $vars[$var]['id'];
	} else {
		$tfact = $fact;
		if (($fact == "EVEN" || $fact == "FACT") && is_string($type) && $type != " ") {
			// Use :
			// n TYPE This text if string
			$tfact = $type;
		}
		$var = str_replace(array("@fact", "@desc"), array(WT_Gedcom_Tag::getLabel($tfact), $desc), $var);
		if (substr($var, 0, 18) == 'WT_I18N::translate' || substr($var, 0, 15) == 'WT_I18N::number') {
			eval("\$var=$var;");
		}
	}
	// Check if variable is set as a date and reformat the date
	if (isset($attrs['date'])) {
		if ($attrs['date'] === "1") {
			$g = new WT_Date($var);
			$var = $g->display();
		}
	}
	$currentElement->addText($var);
}

/**
 * @param array $attrs an array of key value pairs for the attributes
 */
function factsStartHandler($attrs) {
	// @deprecated
	global $repeats, $repeatsStack, $gedrec, $parser, $repeatBytes, $processRepeats, $vars;

	$processRepeats++;
	if ($processRepeats > 1) {
		return;
	}

	array_push($repeatsStack, array($repeats, $repeatBytes));
	$repeats = array();
	$repeatBytes = xml_get_current_line_number($parser);

	$id = "";
	$match = array();
	if (preg_match("/0 @(.+)@/", $gedrec, $match)) {
		$id = $match[1];
	}
	$tag = "";
	if (isset($attrs['ignore'])) {
		$tag .= $attrs['ignore'];
	}
	if (preg_match("/\\$(.+)/", $tag, $match)) {
		$tag = $vars[$match[1]]['id'];
	}

	$record = WT_GedcomRecord::getInstance($id);
	if (empty($attrs['diff']) && !empty($id)) {
		$facts = $record->getFacts();
		sort_facts($facts);
		$repeats = array();
		$nonfacts = explode(',', $tag);
		foreach ($facts as $event) {
			if (!in_array($event->getTag(), $nonfacts)) {
				$repeats[] = $event->getGedcom();
			}
		}
	} else {
		foreach ($record->getFacts() as $fact) {
			if ($fact->isPendingAddition() && $fact->getTag() <> 'CHAN') {
				$repeats[] = $fact->getGedcom();
			}
		}
	}
}

/**
 * XML </ Facts> end element handler
 */
function factsEndHandler() {
	global $repeats, $repeatsStack, $repeatBytes, $parser, $parserStack, $report, $gedrec, $fact, $desc, $type, $processRepeats;

	$processRepeats--;
	if ($processRepeats > 0) {
		return;
	}

	// Check if there is anything to repeat
	if (count($repeats) > 0) {

		$line = xml_get_current_line_number($parser) - 1;
		$lineoffset = 0;
		foreach ($repeatsStack as $rep) {
			$lineoffset += $rep[1];
		}

		//-- read the xml from the file
		$lines = file($report);
		while ($lineoffset + $repeatBytes > 0 && strpos($lines[$lineoffset + $repeatBytes], '<Facts ') === false) {
			$lineoffset--;
		}
		$lineoffset++;
		$reportxml = "<tempdoc>\n";
		$i = $line + $lineoffset;
		$line_nr = $repeatBytes + $lineoffset;
		while ($line_nr < $i) {
			$reportxml .= $lines[$line_nr];
			$line_nr++;
		}
		// No need to drag this
		unset($lines);
		$reportxml .= "</tempdoc>\n";
		// Save original values
		array_push($parserStack, $parser);
		$oldgedrec = $gedrec;
		$count = count($repeats);
		$i = 0;
		while ($i < $count) {
			$gedrec = $repeats[$i];
			$fact = "";
			$desc = "";
			if (preg_match("/1 (\w+)(.*)/", $gedrec, $match)) {
				$fact = $match[1];
				if ($fact == "EVEN" or $fact == "FACT") {
					$tmatch = array();
					if (preg_match("/2 TYPE (.+)/", $gedrec, $tmatch)) {
						$type = trim($tmatch[1]);
					} else {
						$type = " ";
					}
				}
				$desc = trim($match[2]);
				$desc .= get_cont(2, $gedrec);
			}
			//-- start the sax parser
			$repeat_parser = xml_parser_create();
			$parser = $repeat_parser;
			//-- make sure everything is case sensitive
			xml_parser_set_option($repeat_parser, XML_OPTION_CASE_FOLDING, false);
			//-- set the main element handler functions
			xml_set_element_handler($repeat_parser, "startElement", "endElement");
			//-- set the character data handler
			xml_set_character_data_handler($repeat_parser, "characterData");
			if (!xml_parse($repeat_parser, $reportxml, true)) {
				die(sprintf(
					$reportxml . "\nFactsEHandler XML error: %s at line %d",
					xml_error_string(xml_get_error_code($repeat_parser)),
					xml_get_current_line_number($repeat_parser)
				));
			}
			xml_parser_free($repeat_parser);
			$i++;
		}
		// Restore original values
		$parser = array_pop($parserStack);
		$gedrec = $oldgedrec;
	}
	$temp = array_pop($repeatsStack);
	$repeats = $temp[0];
	$repeatBytes = $temp[1];
}

/**
 * Setting upp or changing variables in the XML
 * The XML variable name and value is stored in the global variable $vars
 *
 * @param array $attrs an array of key value pairs for the attributes
 */
function setVarStartHandler($attrs) {
	global $vars, $gedrec, $fact, $desc, $generation;

	if (empty($attrs['name'])) {
		die("<strong>REPORT ERROR var: </strong> The attribute \"name=\" is missing or not set in the XML file");
	}

	$name = $attrs['name'];
	$value = $attrs['value'];
	$match = array();
	// Current GEDCOM record strings
	if ($value == "@ID") {
		if (preg_match("/0 @(.+)@/", $gedrec, $match)) {
			$value = $match[1];
		}
	} elseif ($value == "@fact") {
		$value = $fact;
	} elseif ($value == "@desc") {
		$value = $desc;
	} elseif ($value == "@generation") {
		$value = $generation;
	} elseif (preg_match("/@(\w+)/", $value, $match)) {
		$gmatch = array();
		if (preg_match("/\d $match[1] (.+)/", $gedrec, $gmatch)) {
			$value = str_replace("@", "", trim($gmatch[1]));
		}
	}
	if (preg_match("/\\$(\w+)/", $name, $match)) {
		$name = $vars["'" . $match[1] . "'"]['id'];
	}
	$count = preg_match_all("/\\$(\w+)/", $value, $match, PREG_SET_ORDER);
	$i = 0;
	while ($i < $count) {
		$t = $vars[$match[$i][1]]['id'];
		$value = preg_replace("/\\$" . $match[$i][1] . "/", $t, $value, 1);
		$i++;
	}
	if (substr($value, 0, 18) == 'WT_I18N::translate' || substr($value, 0, 15) == 'WT_I18N::number') {
		eval("\$value = $value;");
	}
	// Arithmetic functions
	if (preg_match("/(\d+)\s*([\-\+\*\/])\s*(\d+)/", $value, $match)) {
		switch ($match[2]) {
		case "+":
			$t = $match[1] + $match[3];
			$value = preg_replace("/" . $match[1] . "\s*([\-\+\*\/])\s*" . $match[3] . "/", $t, $value);
			break;
		case "-":
			$t = $match[1] - $match[3];
			$value = preg_replace("/" . $match[1] . "\s*([\-\+\*\/])\s*" . $match[3] . "/", $t, $value);
			break;
		case "*":
			$t = $match[1] * $match[3];
			$value = preg_replace("/" . $match[1] . "\s*([\-\+\*\/])\s*" . $match[3] . "/", $t, $value);
			break;
		case "/":
			$t = $match[1] / $match[3];
			$value = preg_replace("/" . $match[1] . "\s*([\-\+\*\/])\s*" . $match[3] . "/", $t, $value);
			break;
		}
	}
	if (strpos($value, "@") !== false) {
		$value = "";
	}
	$vars[$name]['id'] = $value;
}

/**
 * XML <if > start element
 *
 * @param array $attrs an array of key value pairs for the attributes
 */
function ifStartHandler($attrs) {
	global $vars, $gedrec, $processIfs, $fact, $desc, $generation;

	if ($processIfs > 0) {
		$processIfs++;

		return;
	}

	$condition = $attrs['condition'];
	$condition = preg_replace("/\\$(\w+)/", "\$vars[\"$1\"][\"id\"]", $condition);
	$condition = str_replace(array(" LT ", " GT "), array("<", ">"), $condition);
	// Replace the first accurance only once of @fact:DATE or in any other combinations to the current fact, such as BIRT
	$condition = str_replace("@fact", $fact, $condition);
	$match = array();
	$count = preg_match_all("/@([\w:\.]+)/", $condition, $match, PREG_SET_ORDER);
	$i = 0;
	while ($i < $count) {
		$id = $match[$i][1];
		$value = "\"\"";
		if ($id == "ID") {
			if (preg_match("/0 @(.+)@/", $gedrec, $match)) {
				$value = "'" . $match[1] . "'";
			}
		} elseif ($id == "fact") {
			$value = "\"$fact\"";
		} elseif ($id == "desc") {
			$value = "\"" . addslashes($desc) . "\"";
		} elseif ($id == "generation") {
			$value = "\"$generation\"";
		} else {

			$temp = explode(" ", trim($gedrec));
			$level = $temp[0];
			if ($level == 0) {
				$level++;
			}
			$value = get_gedcom_value($id, $level, $gedrec);
			if (empty($value)) {
				$level++;
				$value = get_gedcom_value($id, $level, $gedrec);
			}
			$value = "\"" . addslashes($value) . "\"";
		}
		$condition = str_replace("@$id", $value, $condition);
		$i++;
	}
	$condition = "if ($condition) return true; else return false;";
	$ret = @eval($condition);
	if (!$ret) {
		$processIfs++;
	}
}

/**
 * XML <if /> end element
 */
function ifEndHandler() {
	global $processIfs;
	if ($processIfs > 0) {
		$processIfs--;
	}
}

/**
 * XML <Footnote > start element
 * Collect the Footnote links
 * GEDCOM Records that are protected by Privacy setting will be ignore
 *
 * @param array $attrs an array of key value pairs for the attributes
 */
function footnoteStartHandler($attrs) {
	global $printData, $printDataStack, $currentElement, $footnoteElement, $processFootnote, $gedrec, $ReportRoot;

	$id = "";
	if (preg_match("/[0-9] (.+) @(.+)@/", $gedrec, $match)) {
		$id = $match[2];
	}
	$record = WT_GedcomRecord::GetInstance($id);
	if ($record && $record->canShow()) {
		array_push($printDataStack, $printData);
		$printData = true;
		$style = "";
		if (!empty($attrs['style'])) {
			$style = $attrs['style'];
		}
		$footnoteElement = $currentElement;
		$currentElement = $ReportRoot->createFootnote($style);
	} else {
		$printData = false;
		$processFootnote = false;
	}
}

/**
 * XML <Footnote /> end element
 * Print the collected Footnote data
 */
function footnoteEndHandler() {
	// @deprecated
	global $printData, $printDataStack, $currentElement, $footnoteElement, $processFootnote, $wt_report;

	if ($processFootnote) {
		$printData = array_pop($printDataStack);
		$temp = trim($currentElement->getValue());
		if (strlen($temp) > 3) {
			$wt_report->addElement($currentElement);
		}
		$currentElement = $footnoteElement;
	} else {
		$processFootnote = true;
	}
}

/**
 * XML <FootnoteTexts /> element
 */
function footnoteTextsStartHandler() {
	global $wt_report;

	$temp = "footnotetexts";
	$wt_report->addElement($temp);
}

/**
 * XML <AgeAtDeath /> element handler
 */
function ageAtDeathStartHandler() {
	// TODO: This duplicates functionality in format_fact_date()
	global $currentElement, $gedrec, $factrec;

	$match = array();
	if (preg_match("/0 @(.+)@/", $gedrec, $match)) {
		$person = WT_Individual::getInstance($match[1]);
		// Recorded age
		if (preg_match('/\n2 AGE (.+)/', $factrec, $match)) {
			$fact_age = $match[1];
		} else {
			$fact_age = '';
		}
		if (preg_match('/\n2 HUSB\n3 AGE (.+)/', $factrec, $match)) {
			$husb_age = $match[1];
		} else {
			$husb_age = '';
		}
		if (preg_match('/\n2 WIFE\n3 AGE (.+)/', $factrec, $match)) {
			$wife_age = $match[1];
		} else {
			$wife_age = '';
		}

		// Calculated age
		$birth_date = $person->getBirthDate();
		// Can't use getDeathDate(), as this also gives BURI/CREM events, which
		// wouldn't give the correct "days after death" result for people with
		// no DEAT.
		$death_event = $person->getFirstFact('DEAT');
		if ($death_event) {
			$death_date = $death_event->getDate();
		} else {
			$death_date = new WT_Date('');
		}
		$value = '';
		if (WT_Date::Compare($birth_date, $death_date) <= 0 || !$person->isDead()) {
			$age = WT_Date::GetAgeGedcom($birth_date, $death_date);
			// Only show calculated age if it differs from recorded age
			if ($age != '' && $age != "0d") {
				if ($fact_age != '' && $fact_age != $age || $fact_age == '' && $husb_age == '' && $wife_age == '' || $husb_age != '' && $person->getSex() == 'M' && $husb_age != $age || $wife_age != '' && $person->getSex() == 'F' && $wife_age != $age
				) {
					$value = get_age_at_event($age, false);
					$abbrev = substr($value, 0, strpos($value, ' ') + 5);
					if ($value !== $abbrev) {
						$value = $abbrev . '.';
					}
				}
			}
		}
		$currentElement->addText($value);
	}
}

/**
 * XML element Forced line break handler - HTML code
 *
 */
function brStartHandler() {
	global $printData, $currentElement, $processGedcoms;
	if ($printData && ($processGedcoms == 0)) {
		$currentElement->addText('<br>');
	}
}

/**
 * XML <sp />element Forced space handler
 */
function spStartHandler() {
	global $printData, $currentElement, $processGedcoms;
	if ($printData && ($processGedcoms == 0)) {
		$currentElement->addText(' ');
	}
}

/**
 * @param array $attrs an array of key value pairs for the attributes
 */
function highlightedImageStartHandler($attrs) {
	global $gedrec, $wt_report, $ReportRoot;

	$id = '';
	$match = array();
	if (preg_match("/0 @(.+)@/", $gedrec, $match)) {
		$id = $match[1];
	}

	// mixed Position the top corner of this box on the page. the default is the current position
	$top = '.';
	if (isset($attrs['top'])) {
		if ($attrs['top'] === '0') {
			$top = 0;
		} elseif ($attrs['top'] === '.') {
			$top = '.';
		} elseif (!empty($attrs['top'])) {
			$top = (int)$attrs['top'];
		}
	}

	// mixed Position the left corner of this box on the page. the default is the current position
	$left = '.';
	if (isset($attrs['left'])) {
		if ($attrs['left'] === '0') {
			$left = 0;
		} elseif ($attrs['left'] === '.') {
			$left = '.';
		} elseif (!empty($attrs['left'])) {
			$left = (int)$attrs['left'];
		}
	}

	// string Align the image in left, center, right
	$align = '';
	if (!empty($attrs['align'])) {
		$align = $attrs['align'];
	}

	// string Next Line should be T:next to the image, N:next line
	$ln = '';
	if (!empty($attrs['ln'])) {
		$ln = $attrs['ln'];
	}

	$width = 0;
	$height = 0;
	if (!empty($attrs['width'])) {
		$width = (int)$attrs['width'];
	}
	if (!empty($attrs['height'])) {
		$height = (int)$attrs['height'];
	}

	$person = WT_Individual::getInstance($id);
	$mediaobject = $person->findHighlightedMedia();
	if ($mediaobject) {
		$attributes = $mediaobject->getImageAttributes('thumb');
		if (in_array(
				$attributes['ext'],
				array(
					'GIF',
					'JPG',
					'PNG',
					'SWF',
					'PSD',
					'BMP',
					'TIFF',
					'TIFF',
					'JPC',
					'JP2',
					'JPX',
					'JB2',
					'SWC',
					'IFF',
					'WBMP',
					'XBM'
				)
			) && $mediaobject->canShow() && $mediaobject->fileExists('thumb')
		) {
			if (($width > 0) and ($height == 0)) {
				$perc = $width / $attributes['adjW'];
				$height = round($attributes['adjH'] * $perc);
			} elseif ($height > 0 && $width == 0) {
				$perc = $height / $attributes['adjH'];
				$width = round($attributes['adjW'] * $perc);
			} else {
				$width = $attributes['adjW'];
				$height = $attributes['adjH'];
			}
			$image = $ReportRoot->createImageFromObject($mediaobject, $left, $top, $width, $height, $align, $ln);
			$wt_report->addElement($image);
		}
	}
}

/**
 * @param array $attrs an array of key value pairs for the attributes
 */
function imageStartHandler($attrs) {
	global $gedrec, $wt_report, $ReportRoot;

	// mixed Position the top corner of this box on the page. the default is the current position
	$top = '.';
	if (isset($attrs['top'])) {
		if ($attrs['top'] === "0") {
			$top = 0;
		} elseif ($attrs['top'] === '.') {
			$top = '.';
		} elseif (!empty($attrs['top'])) {
			$top = (int)$attrs['top'];
		}
	}

	// mixed Position the left corner of this box on the page. the default is the current position
	$left = '.';
	if (isset($attrs['left'])) {
		if ($attrs['left'] === '0') {
			$left = 0;
		} elseif ($attrs['left'] === '.') {
			$left = '.';
		} elseif (!empty($attrs['left'])) {
			$left = (int)$attrs['left'];
		}
	}

	// string Align the image in left, center, right
	$align = '';
	if (!empty($attrs['align'])) {
		$align = $attrs['align'];
	}

	// string Next Line should be T:next to the image, N:next line
	$ln = 'T';
	if (!empty($attrs['ln'])) {
		$ln = $attrs['ln'];
	}

	$width = 0;
	$height = 0;
	if (!empty($attrs['width'])) {
		$width = (int)$attrs['width'];
	}
	if (!empty($attrs['height'])) {
		$height = (int)$attrs['height'];
	}

	$file = '';
	if (!empty($attrs['file'])) {
		$file = $attrs['file'];
	}
	if ($file == "@FILE") {
		$match = array();
		if (preg_match("/\d OBJE @(.+)@/", $gedrec, $match)) {
			$mediaobject = WT_Media::getInstance($match[1], WT_GED_ID);
			$attributes = $mediaobject->getImageAttributes('thumb');
			if (in_array(
					$attributes['ext'],
					array(
						'GIF',
						'JPG',
						'PNG',
						'SWF',
						'PSD',
						'BMP',
						'TIFF',
						'TIFF',
						'JPC',
						'JP2',
						'JPX',
						'JB2',
						'SWC',
						'IFF',
						'WBMP',
						'XBM'
					)
				) && $mediaobject->canShow() && $mediaobject->fileExists('thumb')
			) {
				if (($width > 0) and ($height == 0)) {
					$perc = $width / $attributes['adjW'];
					$height = round($attributes['adjH'] * $perc);
				} elseif ($height > 0 && $width == 0) {
					$perc = $height / $attributes['adjH'];
					$width = round($attributes['adjW'] * $perc);
				} else {
					$width = $attributes['adjW'];
					$height = $attributes['adjH'];
				}
				$image = $ReportRoot->createImageFromObject($mediaobject, $left, $top, $width, $height, $align, $ln);
				$wt_report->addElement($image);
			}
		}
	} else {
		if (file_exists($file) && preg_match("/(jpg|jpeg|png|gif)$/i", $file)) {
			$size = getimagesize($file);
			if (($width > 0) and ($height == 0)) {
				$perc = $width / $size[0];
				$height = round($size[1] * $perc);
			} elseif ($height > 0 && $width == 0) {
				$perc = $height / $size[1];
				$width = round($size[0] * $perc);
			} else {
				$width = $size[0];
				$height = $size[1];
			}
			$image = $ReportRoot->createImage($file, $left, $top, $width, $height, $align, $ln);
			$wt_report->addElement($image);
		}
	}
}

/**
 * XML <Line> element handler
 *
 * @param array $attrs an array of key value pairs for the attributes
 */
function lineStartHandler($attrs) {
	global $wt_report, $ReportRoot;

	// Start horizontal position, current position (default)
	$x1 = ".";
	if (isset($attrs['x1'])) {
		if ($attrs['x1'] === "0") {
			$x1 = 0;
		} elseif ($attrs['x1'] === ".") {
			$x1 = ".";
		} elseif (!empty($attrs['x1'])) {
			$x1 = (int)$attrs['x1'];
		}
	}
	// Start vertical position, current position (default)
	$y1 = ".";
	if (isset($attrs['y1'])) {
		if ($attrs['y1'] === "0") {
			$y1 = 0;
		} elseif ($attrs['y1'] === ".") {
			$y1 = ".";
		} elseif (!empty($attrs['y1'])) {
			$y1 = (int)$attrs['y1'];
		}
	}
	// End horizontal position, maximum width (default)
	$x2 = ".";
	if (isset($attrs['x2'])) {
		if ($attrs['x2'] === "0") {
			$x2 = 0;
		} elseif ($attrs['x2'] === ".") {
			$x2 = ".";
		} elseif (!empty($attrs['x2'])) {
			$x2 = (int)$attrs['x2'];
		}
	}
	// End vertical position
	$y2 = ".";
	if (isset($attrs['y2'])) {
		if ($attrs['y2'] === "0") {
			$y2 = 0;
		} elseif ($attrs['y2'] === ".") {
			$y2 = ".";
		} elseif (!empty($attrs['y2'])) {
			$y2 = (int)$attrs['y2'];
		}
	}

	$line = $ReportRoot->createLine($x1, $y1, $x2, $y2);
	$wt_report->addElement($line);
}

/**
 * XML <List> start element handler
 *
 * @param array $attrs an array of key value pairs for the attributes
 */
function listStartHandler($attrs) {
	global $gedrec, $repeats, $repeatBytes, $list, $repeatsStack, $processRepeats, $parser, $vars, $sortby;

	$processRepeats++;
	if ($processRepeats > 1) {
		return;
	}

	$match = array();
	if (isset($attrs['sortby'])) {
		$sortby = $attrs['sortby'];
		if (preg_match("/\\$(\w+)/", $sortby, $match)) {
			$sortby = $vars[$match[1]]['id'];
			$sortby = trim($sortby);
		}
	} else {
		$sortby = "NAME";
	}

	if (isset($attrs['list'])) {
		$listname = $attrs['list'];
	} else {
		$listname = "individual";
	}
	// Some filters/sorts can be applied using SQL, while others require PHP
	switch ($listname) {
	case "pending":
		$rows = WT_DB::prepare(
			"SELECT xref, gedcom_id, CASE new_gedcom WHEN '' THEN old_gedcom ELSE new_gedcom END AS gedcom" . " FROM `##change`" . " WHERE (xref, change_id) IN (" . "  SELECT xref, MAX(change_id)" . "   FROM `##change`" . "   WHERE status='pending' AND gedcom_id=?" . "   GROUP BY xref" . " )"
		)->execute(array(WT_GED_ID))->fetchAll();
		$list = array();
		foreach ($rows as $row) {
			$list[] = WT_GedcomRecord::getInstance($row->xref, $row->gedcom_id, $row->gedcom);
		}
		break;
	case "individual":
	case "family":
		$sql_col_prefix = substr($listname, 0, 1) . "_"; // i_ for individual, f_ for family, etc.
		$sql_join = array();
		$sql_where = array($sql_col_prefix . "file=" . WT_GED_ID);
		$sql_order_by = array();
		foreach ($attrs as $attr => $value) {
			if ((strpos($attr, "filter") === 0) && $value) {
				// Substitute global vars
				$value = preg_replace_callback(
					'/\$(\w+)/',
					function ($matches) use ($vars) {
						return $vars[$matches[1]]['id'];
					},
					$value
				);
				// Convert the various filters into SQL
				if (preg_match('/^(\w+):DATE (LTE|GTE) (.+)$/', $value, $match)) {
					$sql_join[] = "JOIN `##dates` AS {$attr} ON ({$attr}.d_file={$sql_col_prefix}file AND {$attr}.d_gid={$sql_col_prefix}id)";
					$sql_where[] = "{$attr}.d_fact='{$match[1]}'";
					$date = new WT_Date($match[3]);
					if ($match[2] == "LTE") {
						$sql_where[] = "{$attr}.d_julianday2<=" . $date->minJD();
					} else {
						$sql_where[] = "{$attr}.d_julianday1>=" . $date->minJD();
					}
					if ($sortby == $match[1]) {
						$sortby = "";
						$sql_order_by[] = "{$attr}.d_julianday1";
					}
					unset($attrs[$attr]); // This filter has been fully processed
				} elseif (($listname == "individual") && (preg_match('/^NAME CONTAINS (.*)$/', $value, $match))) {
					// Do nothing, unless you have to
					if (($match[1] != "") or ($sortby == "NAME")) {
						$sql_join[] = "JOIN `##name` AS {$attr} ON (n_file={$sql_col_prefix}file AND n_id={$sql_col_prefix}id)";
						// Search the DB only if there is any name supplied
						if ($match[1] != "") {
							$names = explode(" ", $match[1]);
							foreach ($names as $name) {
								$sql_where[] = "{$attr}.n_full LIKE " . WT_DB::quote("%{$name}%");
							}
						}
						// Let the DB do the name sorting even when no name was entered
						if ($sortby == "NAME") {
							$sortby = "";
							$sql_order_by[] = "{$attr}.n_sort";
						}
					}
					unset($attrs[$attr]); // This filter has been fully processed
				} elseif (($listname == "individual") && (preg_match('/^REGEXP \/(.+)\//', $value, $match))) {
					$sql_where[] = "i_gedcom REGEXP '" . $match[1] . "'";
					unset($attrs[$attr]); // This filter has been fully processed
				} elseif (($listname == "family") && (preg_match('/^REGEXP \/(.+)\//', $value, $match))) {
					$sql_where[] = "f_gedcom REGEXP '" . $match[1] . "'";
					unset($attrs[$attr]); // This filter has been fully processed
				} elseif (($listname == "family") && (preg_match('/^NAME CONTAINS (.+)$/', $value, $match))) {
					// Eventually, family "names" will be stored in wt_name.  Until then, an extra is needed....
					$sql_join[] = "JOIN `##link` AS {$attr}a ON ({$attr}a.l_file={$sql_col_prefix}file AND {$attr}a.l_from={$sql_col_prefix}id)";
					$sql_join[] = "JOIN `##name` AS {$attr}b ON ({$attr}b.n_file={$sql_col_prefix}file AND n_id={$sql_col_prefix}id)";
					$sql_where[] = "{$attr}a.l_type=IN ('HUSB, 'WIFE')";
					$sql_where[] = "{$attr}.n_full LIKE " . WT_DB::quote("%{$match[1]}%");
					if ($sortby == "NAME") {
						$sortby = "";
						$sql_order_by[] = "{$attr}.n_sort";
					}
					unset($attrs[$attr]); // This filter has been fully processed
				} elseif (preg_match('/^(?:\w+):PLAC CONTAINS (.+)$/', $value, $match)) {
					$sql_join[] = "JOIN `##places` AS {$attr}a ON ({$attr}a.p_file={$sql_col_prefix}file)";
					$sql_join[] = "JOIN `##placelinks` AS {$attr}b ON ({$attr}a.p_file={$attr}b.pl_file AND {$attr}b.pl_p_id={$attr}a.p_id AND {$attr}b.pl_gid={$sql_col_prefix}id)";
					$sql_where[] = "{$attr}a.p_place LIKE " . WT_DB::quote("%{$match[1]}%");
					// Don't unset this filter. This is just the first primary PLAC filter to reduce the returned list from the DB
				} /**
				 * General Purpose DB Filter for Individual and Family Lists
				 * Place any other filter before these filters because they will pick up any filters that has not been processed
				 * Also, do not unset() these two filters. These are just the first primary filters to reduce the returned list from the DB
				 */ elseif ($listname == "individual" && preg_match('/^(\w*):*(\w*) CONTAINS (.+)$/', $value, $match)) {
					$query = "";
					// Level 1 tag
					if ($match[1] != "") {
						$query .= "%1 {$match[1]}%";
					}
					// Level 2 tag
					if ($match[2] != "") {
						$query .= "%2 {$match[2]}%";
					}
					// Contains what?
					if ($match[3] != "") {
						$query .= "%{$match[3]}%";
					}
					$sql_where[] = "i_gedcom LIKE " . WT_DB::quote($query);
				} elseif ($listname == "family" && preg_match('/^(\w*):*(\w*) CONTAINS (.+)$/', $value, $match)) {
					$query = "";
					// Level 1 tag
					if ($match[1] != "") {
						$query .= "%1 {$match[1]}%";
					}
					// Level 2 tag
					if ($match[2] != "") {
						$query .= "%2 {$match[2]}%";
					}
					// Contains what?
					if ($match[3] != "") {
						$query .= "%{$match[3]}%";
					}
					$sql_where[] = "f_gedcom LIKE " . WT_DB::quote($query);
				} else {
					// What other filters can we apply in SQL?
				}
			}
		}
		if ($listname == "family") {
			$list = search_fams_custom($sql_join, $sql_where, $sql_order_by);
		} else {
			$list = search_indis_custom($sql_join, $sql_where, $sql_order_by);
		}
		// Clean up the SQL queries - they will not be used again
		unset($sql_join, $sql_where, $sql_order_by);
		break;
	default:
		die("Invalid list name: $listname");
	}

	$filters = array();
	$filters2 = array();
	if ((isset($attrs['filter1'])) and (count($list) > 0)) {
		foreach ($attrs as $key => $value) {
			if (preg_match("/filter(\d)/", $key)) {
				$condition = $value;
				if (preg_match("/@(\w+)/", $condition, $match)) {
					$id = $match[1];
					$value = "''";
					if ($id == "ID") {
						if (preg_match("/0 @(.+)@/", $gedrec, $match)) {
							$value = "'" . $match[1] . "'";
						}
					} elseif ($id == "fact") {
						$value = "'$fact'";
					} elseif ($id == "desc") {
						$value = "'$desc'";
					} else {
						if (preg_match("/\d $id (.+)/", $gedrec, $match)) {
							$value = "'" . str_replace("@", "", trim($match[1])) . "'";
						}
					}
					$condition = preg_replace("/@$id/", $value, $condition);
				}
				//-- handle regular expressions
				if (preg_match("/([A-Z:]+)\s*([^\s]+)\s*(.+)/", $condition, $match)) {
					$tag = trim($match[1]);
					$expr = trim($match[2]);
					$val = trim($match[3]);
					if (preg_match("/\\$(\w+)/", $val, $match)) {
						$val = $vars[$match[1]]['id'];
						$val = trim($val);
					}
					if ($val) {
						$searchstr = "";
						$tags = explode(":", $tag);
						//-- only limit to a level number if we are specifically looking at a level
						if (count($tags) > 1) {
							$level = 1;
							foreach ($tags as $t) {
								if (!empty($searchstr)) {
									$searchstr .= "[^\n]*(\n[2-9][^\n]*)*\n";
								}
								//-- search for both EMAIL and _EMAIL... silly double gedcom standard
								if ($t == "EMAIL" || $t == "_EMAIL") {
									$t = "_?EMAIL";
								}
								$searchstr .= $level . " " . $t;
								$level++;
							}
						} else {
							if ($tag == "EMAIL" || $tag == "_EMAIL") {
								$tag = "_?EMAIL";
							}
							$t = $tag;
							$searchstr = "1 " . $tag;
						}
						switch ($expr) {
						case "CONTAINS":
							if ($t == "PLAC") {
								$searchstr .= "[^\n]*[, ]*" . $val;
							} else {
								$searchstr .= "[^\n]*" . $val;
							}
							$filters[] = $searchstr;
							break;
						default:
							$filters2[] = array("tag" => $tag, "expr" => $expr, "val" => $val);
							break;
						}
					}
				}
			}
		}
	}
	//-- apply other filters to the list that could not be added to the search string
	if ($filters) {
		foreach ($list as $key => $record) {
			foreach ($filters as $filter) {
				if (!preg_match("/" . $filter . "/i", $record->privatizeGedcom(WT_USER_ACCESS_LEVEL))) {
					unset($list[$key]);
					break;
				}
			}
		}
	}
	if ($filters2) {
		$mylist = array();
		foreach ($list as $indi) {
			$key = $indi->getXref();
			$grec = $indi->privatizeGedcom(WT_USER_ACCESS_LEVEL);
			$keep = true;
			foreach ($filters2 as $filter) {
				if ($keep) {
					$tag = $filter['tag'];
					$expr = $filter['expr'];
					$val = $filter['val'];
					if ($val == "''") {
						$val = "";
					}
					$tags = explode(":", $tag);
					$t = end($tags);
					$v = get_gedcom_value($tag, 1, $grec);
					//-- check for EMAIL and _EMAIL (silly double gedcom standard :P)
					if ($t == "EMAIL" && empty($v)) {
						$tag = str_replace("EMAIL", "_EMAIL", $tag);
						$tags = explode(":", $tag);
						$t = end($tags);
						$v = get_sub_record(1, $tag, $grec);
					}

					switch ($expr) {
					case "GTE":
						if ($t == "DATE") {
							$date1 = new WT_Date($v);
							$date2 = new WT_Date($val);
							$keep = (WT_Date::Compare($date1, $date2) >= 0);
						} elseif ($val >= $v) {
							$keep = true;
						}
						break;
					case "LTE":
						if ($t == "DATE") {
							$date1 = new WT_Date($v);
							$date2 = new WT_Date($val);
							$keep = (WT_Date::Compare($date1, $date2) <= 0);
						} elseif ($val >= $v) {
							$keep = true;
						}
						break;
					default:
						if ($v == $val) {
							$keep = true;
						} else {
							$keep = false;
						}
						break;
					}
				}
			}
			if ($keep) {
				$mylist[$key] = $indi;
			}
		}
		$list = $mylist;
	}

	switch ($sortby) {
	case "NAME":
		uasort($list, array("WT_GedcomRecord", "compare"));
		break;
	case "CHAN":
		uasort($list, function (WT_GedcomRecord $x, WT_GedcomRecord $y) {
			return $y->lastChangeTimestamp(true) - $x->lastChangeTimestamp(true);
		});
		break;
	case "BIRT:DATE":
		uasort($list, array("WT_Individual", "compareBirthDate"));
		break;
	case "DEAT:DATE":
		uasort($list, array("WT_Individual", "compareDeathDate"));
		break;
	case "MARR:DATE":
		uasort($list, array("WT_Family", "compareMarrDate"));
		break;
	default:
		// unsorted or already sorted by SQL
		break;
	}

	array_push($repeatsStack, array($repeats, $repeatBytes));
	$repeatBytes = xml_get_current_line_number($parser) + 1;
}

/**
 * XML <List> end element handler
 */
function listEndHandler() {
	global $list, $repeats, $repeatsStack, $repeatBytes, $parser, $parserStack, $report, $gedrec, $processRepeats, $list_total, $list_private;

	$processRepeats--;
	if ($processRepeats > 0) {
		return;
	}

	// Check if there is any list
	if (count($list) > 0) {
		$lineoffset = 0;
		foreach ($repeatsStack as $rep) {
			$lineoffset += $rep[1];
		}
		//-- read the xml from the file
		$lines = file($report);
		while ((strpos($lines[$lineoffset + $repeatBytes], "<List") === false) && (($lineoffset + $repeatBytes) > 0)) {
			$lineoffset--;
		}
		$lineoffset++;
		$reportxml = "<tempdoc>\n";
		$line_nr = $lineoffset + $repeatBytes;
		// List Level counter
		$count = 1;
		while (0 < $count) {
			if (strpos($lines[$line_nr], "<List") !== false) {
				$count++;
			} elseif (strpos($lines[$line_nr], "</List") !== false) {
				$count--;
			}
			if (0 < $count) {
				$reportxml .= $lines[$line_nr];
			}
			$line_nr++;
		}
		// No need to drag this
		unset($lines);
		$reportxml .= "</tempdoc>";
		// Save original values
		array_push($parserStack, $parser);
		$oldgedrec = $gedrec;

		$list_total = count($list);
		$list_private = 0;
		foreach ($list as $record) {
			if ($record->canShow()) {
				$gedrec = $record->privatizeGedcom(WT_USER_ACCESS_LEVEL);
				//-- start the sax parser
				$repeat_parser = xml_parser_create();
				$parser = $repeat_parser;
				//-- make sure everything is case sensitive
				xml_parser_set_option($repeat_parser, XML_OPTION_CASE_FOLDING, false);
				//-- set the main element handler functions
				xml_set_element_handler($repeat_parser, "startElement", "endElement");
				//-- set the character data handler
				xml_set_character_data_handler($repeat_parser, "characterData");
				if (!xml_parse($repeat_parser, $reportxml, true)) {
					printf(
						$reportxml . "\nListEHandler XML error: %s at line %d",
						xml_error_string(xml_get_error_code($repeat_parser)),
						xml_get_current_line_number($repeat_parser)
					);
					exit;
				}
				xml_parser_free($repeat_parser);
			} else {
				$list_private++;
			}
		}
		// Clean up the GLOBAL list array
		unset($list);
		$parser = array_pop($parserStack);
		$gedrec = $oldgedrec;
	}
	$temp = array_pop($repeatsStack);
	$repeats = $temp[0];
	$repeatBytes = $temp[1];
}

/**
 * XML <ListTotal> element handler
 *
 * Prints the total number of records in a list
 * The total number is collected from
 * List and Relatives
 */
function listTotalStartHandler() {
	global $list_total, $list_private, $currentElement;

	if (empty($list_total)) {
		$list_total = 0;
	}

	if ($list_private == 0) {
		$currentElement->addText($list_total);
	} else {
		$currentElement->addText(($list_total - $list_private) . " / " . $list_total);
	}
}

/**
 * @param array $attrs an array of key value pairs for the attributes
 */
function relativesStartHandler($attrs) {
	global $repeats, $repeatBytes, $list, $repeatsStack, $processRepeats, $parser, $vars, $sortby;

	$processRepeats++;
	if ($processRepeats > 1) {
		return;
	}

	$sortby = "NAME";
	if (isset($attrs['sortby'])) {
		$sortby = $attrs['sortby'];
	}
	$match = array();
	if (preg_match("/\\$(\w+)/", $sortby, $match)) {
		$sortby = $vars[$match[1]]['id'];
		$sortby = trim($sortby);
	}

	$maxgen = -1;
	if (isset($attrs['maxgen'])) {
		$maxgen = $attrs['maxgen'];
	}
	if ($maxgen == "*") {
		$maxgen = -1;
	}

	$group = "child-family";
	if (isset($attrs['group'])) {
		$group = $attrs['group'];
	}
	if (preg_match("/\\$(\w+)/", $group, $match)) {
		$group = $vars[$match[1]]['id'];
		$group = trim($group);
	}

	$id = "";
	if (isset($attrs['id'])) {
		$id = $attrs['id'];
	}
	if (preg_match("/\\$(\w+)/", $id, $match)) {
		$id = $vars[$match[1]]['id'];
		$id = trim($id);
	}

	$list = array();
	$person = WT_Individual::getInstance($id);
	if (!empty($person)) {
		$list[$id] = $person;
		switch ($group) {
		case "child-family":
			foreach ($person->getChildFamilies() as $family) {
				$husband = $family->getHusband();
				$wife = $family->getWife();
				if (!empty($husband)) {
					$list[$husband->getXref()] = $husband;
				}
				if (!empty($wife)) {
					$list[$wife->getXref()] = $wife;
				}
				$children = $family->getChildren();
				foreach ($children as $child) {
					if (!empty($child)) {
						$list[$child->getXref()] = $child;
					}
				}
			}
			break;
		case "spouse-family":
			foreach ($person->getSpouseFamilies() as $family) {
				$husband = $family->getHusband();
				$wife = $family->getWife();
				if (!empty($husband)) {
					$list[$husband->getXref()] = $husband;
				}
				if (!empty($wife)) {
					$list[$wife->getXref()] = $wife;
				}
				$children = $family->getChildren();
				foreach ($children as $child) {
					if (!empty($child)) {
						$list[$child->getXref()] = $child;
					}
				}
			}
			break;
		case "direct-ancestors":
			add_ancestors($list, $id, false, $maxgen);
			break;
		case "ancestors":
			add_ancestors($list, $id, true, $maxgen);
			break;
		case "descendants":
			$list[$id]->generation = 1;
			add_descendancy($list, $id, false, $maxgen);
			break;
		case "all":
			add_ancestors($list, $id, true, $maxgen);
			add_descendancy($list, $id, true, $maxgen);
			break;
		}
	}

	switch ($sortby) {
	case "NAME":
		uasort($list, array("WT_GedcomRecord", "compare"));
		break;
	case "BIRT:DATE":
		uasort($list, array("WT_Individual", "compareBirthDate"));
		break;
	case "DEAT:DATE":
		uasort($list, array("WT_Individual", "compareDeathDate"));
		break;
	case "generation":
		$newarray = array();
		reset($list);
		$genCounter = 1;
		while (count($newarray) < count($list)) {
			foreach ($list as $key => $value) {
				$generation = $value->generation;
				if ($generation == $genCounter) {
					$newarray[$key] = new stdClass();
					$newarray[$key]->generation = $generation;
				}
			}
			$genCounter++;
		}
		$list = $newarray;
		break;
	default:
		// unsorted
		break;
	}
	array_push($repeatsStack, array($repeats, $repeatBytes));
	$repeatBytes = xml_get_current_line_number($parser) + 1;
}

/**
 * XML </ Relatives> end element handler
 */
function relativesEndHandler() {
	global $list, $repeats, $repeatsStack, $repeatBytes, $parser, $parserStack, $report, $gedrec, $processRepeats, $list_total, $list_private, $generation;

	$processRepeats--;
	if ($processRepeats > 0) {
		return;
	}

	// Check if there is any relatives
	if (count($list) > 0) {
		$lineoffset = 0;
		foreach ($repeatsStack as $rep) {
			$lineoffset += $rep[1];
		}
		//-- read the xml from the file
		$lines = file($report);
		while ((strpos($lines[$lineoffset + $repeatBytes], "<Relatives") === false) && (($lineoffset + $repeatBytes) > 0)) {
			$lineoffset--;
		}
		$lineoffset++;
		$reportxml = "<tempdoc>\n";
		$line_nr = $lineoffset + $repeatBytes;
		// Relatives Level counter
		$count = 1;
		while (0 < $count) {
			if (strpos($lines[$line_nr], "<Relatives") !== false) {
				$count++;
			} elseif (strpos($lines[$line_nr], "</Relatives") !== false) {
				$count--;
			}
			if (0 < $count) {
				$reportxml .= $lines[$line_nr];
			}
			$line_nr++;
		}
		// No need to drag this
		unset($lines);
		$reportxml .= "</tempdoc>\n";
		// Save original values
		array_push($parserStack, $parser);
		$oldgedrec = $gedrec;

		$list_total = count($list);
		$list_private = 0;
		foreach ($list as $key => $value) {
			if (isset($value->generation)) {
				$generation = $value->generation;
			}
			$tmp = WT_GedcomRecord::getInstance($key);
			$gedrec = $tmp->privatizeGedcom(WT_USER_ACCESS_LEVEL);
			//-- start the sax parser
			$repeat_parser = xml_parser_create();
			$parser = $repeat_parser;
			//-- make sure everything is case sensitive
			xml_parser_set_option($repeat_parser, XML_OPTION_CASE_FOLDING, false);
			//-- set the main element handler functions
			xml_set_element_handler($repeat_parser, "startElement", "endElement");
			//-- set the character data handler
			xml_set_character_data_handler($repeat_parser, "characterData");

			if (!xml_parse($repeat_parser, $reportxml, true)) {
				printf(
					$reportxml . "\nRelativesEHandler XML error: %s at line %d",
					xml_error_string(xml_get_error_code($repeat_parser)),
					xml_get_current_line_number($repeat_parser)
				);
				exit;
			}
			xml_parser_free($repeat_parser);
		}
		// Clean up the GLOBAL list array
		unset($list);
		$parser = array_pop($parserStack);
		$gedrec = $oldgedrec;
	}
	$temp = array_pop($repeatsStack);
	$repeats = $temp[0];
	$repeatBytes = $temp[1];
}

/**
 * XML <Generation /> element handler
 *
 * Prints the number of generations
 */
function generationStartHandler() {
	global $generation, $currentElement;

	if (empty($generation)) {
		$generation = 1;
	}

	$currentElement->addText($generation);
}

/**
 * XML <NewPage /> element handler
 *
 * Has to be placed in an element (header, pageheader, body or footer)
 */
function newPageStartHandler() {
	global $wt_report;

	$temp = "addpage";
	$wt_report->addElement($temp);
}

/**
 * @param array  $attrs an array of key value pairs for the attributes
 * @param string $tag   HTML tag name
 */
function htmlStartHandler($tag, $attrs) {
	global $printData, $printDataStack, $wt_reportStack, $wt_report, $currentElement, $ReportRoot;

	if ($tag == "tempdoc") {
		return;
	}
	array_push($wt_reportStack, $wt_report);
	$wt_report = $ReportRoot->createHTML($tag, $attrs);
	$currentElement = $wt_report;

	array_push($printDataStack, $printData);
	$printData = true;
}

/**
 * @param string $tag
 */
function htmlEndHandler($tag) {
	global $printData, $printDataStack, $wt_report, $currentElement, $wt_reportStack;
	if ($tag == "tempdoc") {
		return;
	}

	$printData = array_pop($printDataStack);
	$currentElement = $wt_report;
	$wt_report = array_pop($wt_reportStack);
	if (!is_null($wt_report)) {
		$wt_report->addElement($currentElement);
	} else {
		$wt_report = $currentElement;
	}
}

/**
 * XML <titleStartHandler> start element handler
 */
function titleStartHandler() {
	global $reportTitle;
	$reportTitle = true;
}

/**
 * XML </titleEndHandler> end element handler
 */
function titleEndHandler() {
	global $reportTitle;
	$reportTitle = false;
}

/**
 * XML <descriptionStartHandler> start element handler
 */
function descriptionStartHandler() {
	global $reportDescription;
	$reportDescription = true;
}

/**
 * XML </descriptionEndHandler> end element handler
 */
function descriptionEndHandler() {
	global $reportDescription;
	$reportDescription = false;
}

/**
 * get gedcom tag value
 *
 * @param string  $tag    The tag to find, use : to delineate subtags
 * @param integer $level  The gedcom line level of the first tag to find, setting level to 0 will cause it to use 1+ the level of the incoming record
 * @param string  $gedrec The gedcom record to get the value from
 *
 * @return string the value of a gedcom tag from the given gedcom record
 */
function get_gedcom_value($tag, $level, $gedrec) {
	if (empty($gedrec)) {
		return '';
	}
	$tags = explode(':', $tag);
	$origlevel = $level;
	if ($level == 0) {
		$level = $gedrec{0} + 1;
	}

	$subrec = $gedrec;
	foreach ($tags as $t) {
		$lastsubrec = $subrec;
		$subrec = get_sub_record($level, "$level $t", $subrec);
		if (empty($subrec) && $origlevel == 0) {
			$level--;
			$subrec = get_sub_record($level, "$level $t", $lastsubrec);
		}
		if (empty($subrec)) {
			if ($t == "TITL") {
				$subrec = get_sub_record($level, "$level ABBR", $lastsubrec);
				if (!empty($subrec)) {
					$t = "ABBR";
				}
			}
			if (empty($subrec)) {
				if ($level > 0) {
					$level--;
				}
				$subrec = get_sub_record($level, "@ $t", $gedrec);
				if (empty($subrec)) {
					return;
				}
			}
		}
		$level++;
	}
	$level--;
	$ct = preg_match("/$level $t(.*)/", $subrec, $match);
	if ($ct == 0) {
		$ct = preg_match("/$level @.+@ (.+)/", $subrec, $match);
	}
	if ($ct == 0) {
		$ct = preg_match("/@ $t (.+)/", $subrec, $match);
	}
	if ($ct > 0) {
		$value = trim($match[1]);
		if ($t == 'NOTE' && preg_match('/^@(.+)@$/', $value, $match)) {
			$note = WT_Note::getInstance($match[1]);
			if ($note) {
				$value = $note->getNote();
			} else {
				//-- set the value to the id without the @
				$value = $match[1];
			}
		}
		if ($level != 0 || $t != "NOTE") {
			$value .= get_cont($level + 1, $subrec);
		}

		return $value;
	}

	return "";
}

/**
 * @param string[] $list
 * @param string   $pid
 * @param boolean  $children
 * @param integer  $generations
 */
function add_ancestors(&$list, $pid, $children = false, $generations = -1) {
	$genlist = array($pid);
	$list[$pid]->generation = 1;
	while (count($genlist) > 0) {
		$id = array_shift($genlist);
		if (strpos($id, 'empty') === 0) {
			continue; // id can be something like “empty7”
		}
		$person = WT_Individual::getInstance($id);
		foreach ($person->getChildFamilies() as $family) {
			$husband = $family->getHusband();
			$wife = $family->getWife();
			if ($husband) {
				$list[$husband->getXref()] = $husband;
				$list[$husband->getXref()]->generation = $list[$id]->generation + 1;
			}
			if ($wife) {
				$list[$wife->getXref()] = $wife;
				$list[$wife->getXref()]->generation = $list[$id]->generation + 1;
			}
			if ($generations == -1 || $list[$id]->generation + 1 < $generations) {
				if ($husband) {
					array_push($genlist, $husband->getXref());
				}
				if ($wife) {
					array_push($genlist, $wife->getXref());
				}
			}
			if ($children) {
				foreach ($family->getChildren() as $child) {
					$list[$child->getXref()] = $child;
					if (isset($list[$id]->generation)) {
						$list[$child->getXref()]->generation = $list[$id]->generation;
					} else {
						$list[$child->getXref()]->generation = 1;
					}
				}
			}
		}
	}
}

/**
 * @param string[] $list
 * @param string   $pid
 * @param boolean  $parents
 * @param integer  $generations
 */
function add_descendancy(&$list, $pid, $parents = false, $generations = -1) {
	$person = WT_Individual::getInstance($pid);
	if ($person == null) {
		return;
	}
	if (!isset($list[$pid])) {
		$list[$pid] = $person;
	}
	if (!isset($list[$pid]->generation)) {
		$list[$pid]->generation = 0;
	}
	foreach ($person->getSpouseFamilies() as $family) {
		if ($parents) {
			$husband = $family->getHusband();
			$wife = $family->getWife();
			if ($husband) {
				$list[$husband->getXref()] = $husband;
				if (isset($list[$pid]->generation)) {
					$list[$husband->getXref()]->generation = $list[$pid]->generation - 1;
				} else {
					$list[$husband->getXref()]->generation = 1;
				}
			}
			if ($wife) {
				$list[$wife->getXref()] = $wife;
				if (isset($list[$pid]->generation)) {
					$list[$wife->getXref()]->generation = $list[$pid]->generation - 1;
				} else {
					$list[$wife->getXref()]->generation = 1;
				}
			}
		}
		$children = $family->getChildren();
		foreach ($children as $child) {
			if ($child) {
				$list[$child->getXref()] = $child;
				if (isset($list[$pid]->generation)) {
					$list[$child->getXref()]->generation = $list[$pid]->generation + 1;
				} else {
					$list[$child->getXref()]->generation = 2;
				}
			}
		}
		if ($generations == -1 || $list[$pid]->generation + 1 < $generations) {
			foreach ($children as $child) {
				add_descendancy($list, $child->getXref(), $parents, $generations); // recurse on the childs family
			}
		}
	}
}
